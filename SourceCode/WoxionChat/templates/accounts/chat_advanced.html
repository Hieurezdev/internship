{% extends 'accounts/base.html' %}
{% load static %}

{% block title %}Chat N√¢ng Cao - WoxionChat{% endblock %}

{% block content %}
<!-- Th√™m th∆∞ vi·ªán marked.js ƒë·ªÉ x·ª≠ l√Ω Markdown -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
    /* Inter Font - ChatGPT style */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    body {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important; 
        color: #3c4043;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        overflow: hidden; 
    }
    
    /* === THANH TH√îNG B√ÅO === */
    .notification-bar {
        position: fixed;
        top: 70px; /* D∆∞·ªõi navbar */
        left: 0;
        right: 0;
        z-index: 9999;
        background: linear-gradient(135deg, #10a37f, #0d8a6b);
        color: white;
        padding: 12px 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateY(-100%);
        transition: transform 0.3s ease-in-out;
        /* border-bottom: 3px solid #0d8a6b; */
        display: flex;
        justify-content: space-between;
        align-items: center;
        max-height: 150px;
        overflow-y: auto;
    }
    
    /* === TYPEWRITER EFFECT === */
    .typewriter-cursor {
        animation: blink-cursor 1s infinite;
        font-weight: bold;
        color: #10a37f;
    }
    
    @keyframes blink-cursor {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
    
    .message.bot.typing {
        background: rgba(16, 163, 127, 0.05);
        border-left: 3px solid #10a37f;
    }
    
    .message.bot.typing .message-content {
        animation: subtle-pulse 1.5s infinite;
    }
    
    @keyframes subtle-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }
    
    .notification-bar.show {
        transform: translateY(0);
    }
    
    .notification-bar.success {
        background: #10a37f;
        border-bottom-color: #1e7e34;
    }
    
    .notification-bar.error {
        background: linear-gradient(135deg, #dc3545, #c82333);
        border-bottom-color: #bd2130;
    }
    
    .notification-bar.warning {
        background: linear-gradient(135deg, #ffc107, #e0a800);
        border-bottom-color: #d39e00;
        color: #212529;
    }
    
    .notification-bar.info {
        background: linear-gradient(135deg, #17a2b8, #138496);
        border-bottom-color: #117a8b;
    }
    
    .notification-content {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .notification-icon {
        font-size: 1.2rem;
        min-width: 20px;
    }
    
    .notification-message {
        font-size: 0.95rem;
        line-height: 1.4;
        flex: 1;
    }
    
    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s;
    }
    
    .notification-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }
    
    .notification-details {
        margin-top: 8px;
        font-size: 0.85rem;
        opacity: 0.9;
        line-height: 1.3;
    }
    
    .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 3px;
        background-color: rgba(255, 255, 255, 0.3);
        width: 100%;
        transform-origin: left;
        animation: notificationProgress 5s linear forwards;
    }
    
    @keyframes notificationProgress {
        from { transform: scaleX(1); }
        to { transform: scaleX(0); }
    }
    
    #techChatWidget {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 10000;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        display: none;
    }

    main.container {
        background: linear-gradient(rgba(192, 255, 209, 0.498), rgba(202, 255, 233, 0.736)), url('{% static "images/nen.jpg" %}') center/cover no-repeat fixed;
        height: 100vh;
        width: 100vw;
        max-width: 100%;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        position: fixed;
        top: 0;
        left: 0;
        padding-top: 70px; /* Chi·ªÅu cao navbar */
    }

    .notebook-layout {
        display: flex;
        height: calc(100vh - 70px); /* To√†n m√†n h√¨nh tr·ª´ navbar */
        gap: 15px;
        padding: 20px;
        box-sizing: border-box;
    }

    /* === C·ªòT TR√ÅI: NGU·ªíN D·ªÆ LI·ªÜU === */
    .source-panel {
        width: 20%;
        /* flex: 1; */
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: #ffffff;
        border-radius: 20px;
        /* border-top: 4px solid #10a37f; */
    }
    .source-header {
        /* padding: 5px 50px; */
        font-size: 20px;
        font-weight: 375; /* Inter font weight for better readability */
        text-align: center;
        color: #10a37f;
        margin-bottom: 0px;
        padding: 5px;
        /* border-bottom: 1px solid #10a37f; */
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .collapse-btn {
        position: absolute;
        right: 10px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        padding: 5px;
        transition: all 0.2s;
    }
    
    .source-panel.collapsed {
        width: 50px;
        min-width: 50px;
    }
    
    .source-panel.collapsed .source-header {
        writing-mode: vertical-lr;
        text-orientation: mixed;
        font-size: 0; /* Hide the text */
        height: 3%;
        justify-content: center;
        border-bottom: none;
        /* margin-bottom: 0; */
        padding: 0;
    }
    
    .source-panel.collapsed .source-header::before {
        content: "";
        font-size: 0;
    }
    
    .source-panel.collapsed .source-item,
    .source-panel.collapsed .source-actions {
        display: none;
    }
    
    .source-panel.collapsed .collapse-btn {
        position: static;
        margin: 0 auto;
        font-size: 18px;
        transform: rotate(0deg);
    }

    .source-item {
        padding: 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.9rem;
        flex: 1;
        overflow-y: auto;
        border: #10a37f solid 1px;
        background: #ffffff;
        margin-left: 10px;
        margin-right: 10px;   
    }
    
    .user-db-entry {
        background: #f8f9fa;
        padding: 12px;
        margin-bottom: 0;
        position: relative;
        border-bottom: 1px solid #b6b8b9;
        margin-bottom: 4px;
    }
    
    .user-db-entry:last-child {
        border-bottom: none;
    }
    
    .user-db-entry:hover {
        background: #e9ecef;
        transform: translateY(-1px);
    }
    
    .user-db-entry.selected {
        background: #d2e3fc;
        border-color: #10a37f;
    }
    
    /* Chunking status styles */
    .user-db-entry.chunked {
        background: #f1fffa;
        border-color: #4caf50;
        border-left: 4px solid #10a37f;
        border-bottom: 1px solid #10a37f;
        border-right: 1px solid #10a37f;
        border-top: 1px solid #10a37f;
    }
    
    .user-db-entry.chunked:hover {
        background: #d1eede;
    }
    
    .user-db-entry.not-chunked {
        background: #e4e4e4;
        border-left: 4px solid #bdbdbd;
        
    }
    
    .user-db-entry.not-chunked:hover {
        background: #c7c7c7;
    }
    
    .user-db-entry.loading {
        background: #f8f9fa;
        border-color: #6c757d;
        border-left: 4px solid #6c757d;
    }
    
    .user-db-entry.loading:hover {
        background: #e9ecef;
    }
    
    .chunking-status {
        margin-top: 6px;
        margin-bottom: 2px;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
        min-width: 80px;
        max-width: 100%;
        justify-content: flex-start;
        text-align: start;
        width: fit-content;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        box-sizing: border-box;
    }
    .chunking-status {
        /* If text is too long, show ellipsis */
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        max-width: 120px;
    }
    
    .chunking-status.chunked {
        background: None;
        color: #10a37f;
    }
    
    .chunking-status.not-chunked {
        background: None;
        color: #744313;
        /* box-shadow: 0 2px 4px rgba(255, 193, 7, 0.3); */
    }
    
    .chunking-status.loading {
        background: #ea9937;
        color: white;
        box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
    }
    
    .chunking-status i {
        font-size: 0.8rem;
    }
    
    .user-db-username {
        font-weight: 400;
        color: #10a37f;
        margin-bottom: 5px;
        font-family: 'Inter', sans-serif;
    }
    
    .user-db-date {
        font-size: 0.75rem;
        color: #5f6368;
        margin-bottom: 5px;
    }
    
    .user-db-info {
        font-size: 0.8rem;
        color: #666;
        margin-left: 0px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        display: block;
    }
    
    .user-db-actions {
        display: flex;
        gap: 8px;
        margin-top: 5px;
        border-radius: 100%;
        justify-content: flex-start;
        padding: 0;
        height: min-content;
    }
    
    .btn-read-doc, .btn-delete-doc {
        padding: 6px 12px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.75rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .btn-read-doc {
        background: None;
        color: rgb(30,123,94);
    }
    
    .btn-read-doc:hover {
        background: #0d8a6b;
        color: white
    }
    
    .btn-delete-doc {
        color: #dc3545;
        background: None;
    }
    
    .btn-delete-doc:hover {
        background: #c82333;
        color: white;
    }
    
    .source-actions {
        padding: 10px;
        display: flex;
        gap: 10px;
        width: fit-content;
        align-content: center;

    }
    
    .btn-refresh {
        background: white;
        background: #10a37f;
        color: white;
        padding: 8px 8px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 350;
        border: None;
    }
    
    .btn-refresh:hover {
        background: rgb(30,123,94);
        color: white;
        border: None;
    }
    
    .loading-indicator {
        text-align: center;
        padding: 20px;
        color: #5f6368;
    }
    
    .empty-state {
        text-align: center;
        padding: 30px 15px;
        color: #5f6368;
    }
    
    .empty-state i {
        font-size: 2rem;
        margin-bottom: 10px;
        display: block;
    }
    
    /* Modal styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
        background-color: rgba(255, 255, 255, 0.85); /* Fallback for unsupported browsers */
        backdrop-filter: blur(50px);
        margin: 15% auto;
        padding: 20px;
        border-radius: 15px;
        width: 90%;
        max-width: 500px;
        border: 2px solid #10a37f;
        transition: box-shadow 0.3s, transform 0.3s, background-color 0.3s;
    }
    
    .modal-header {
        display: flex;
        /* justify-content: space-between; */
        align-items: center;
        margin-bottom: 20px;
        background: #10a37f;
        color: white;
        font-weight: 375;
        font-size: 1.5rem;
        border-radius: 10px;
    }
    
    .modal-close {
        background: None;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: white;
    }
    
    .form-group {
        margin-bottom: 15px;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #333;
    }
    
    .form-group input, .form-group textarea {
        width: 100%;
        padding: 10px;
        border: 2px solid #10a37f;
        border-radius: 8px;
        font-size: 1rem;
        box-sizing: border-box;
        font-weight: 375;
    }

    
    
    .form-group textarea {
        resize: vertical;
        min-height: 100px;
    }

    .form-group textarea :focus {
        border: 2px solid #10a37f;
    }
    
    .btn-submit {
        background: #10a37f;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        width: 100%;
        transition: background-color 0.2s;
    }
    
    .btn-submit:hover {
        background: rgb(30,123,94);
    }

    /* === C·ªòT PH·∫¢I: CU·ªòC TR√í CHUY·ªÜN === */
    .chat-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: #ffffff;
        border-radius: 20px;
        margin-right: 0;
        /* border-top: 5px solid #10a37f; */
        /* padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px; */
    }
    .chat-panel-header {
        font-size: 20px;
        font-weight: 375; /* Inter font weight for better readability */
        text-align: center;
        color: #10a37f;
        margin-bottom: 20px;
        padding: 5px;
        border-bottom: 1px solid #10a37f;
    }
    .chat-body {
        flex-grow: 1;
        overflow-y: auto;
        padding: 32px 24px;
    }

    /* === TIN NH·∫ÆN === */
    .message {
        display: flex;
        flex-direction: column;
        max-width: 85%;
        width: fit-content;
        margin-bottom: 20px;
        word-wrap: break-word;
        font-size: 1.1rem;
        line-height: 1.6;
        font-family: 'Inter', sans-serif;
        font-weight: 350;
    }
    
    .message.user {
        align-self: flex-end;
        align-items: flex-end;
        margin-left: auto;
        margin-right: 0;
    }

    .message.bot {
        align-self: flex-start;
        align-items: flex-start;
    }
    
    .message-content {
        padding: 12px 18px;
        border-radius: 18px;
        max-width: 100%;
        width: 100%;
        font-family: 'Inter', sans-serif;
        font-weight: 375;
        letter-spacing: -0.01em; /* Slightly tighter letter spacing like ChatGPT */
    }

    .message.user .message-content {
        background: #10a37f; /* Xanh d∆∞∆°ng nh·∫°t cho ng∆∞·ªùi d√πng */
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message.bot .message-content {
        background: #ffffff; /* N·ªÅn tr·∫Øng cho bot */
        color: #3c4043;
        border-bottom: rgb(214, 214, 214);
        border-bottom-left-radius: 4px;
        border: 1px solid #10a37f;
        margin-left: 0;
        align-self: flex-start;
    }
    
    .message-time {
        font-size: 0.75rem;
        color: #10a37f;
        margin-top: 2px;
        padding: 0 5px;
        flex: 1; 
        display: flex;
        align-items: flex-start; /* Align above (top) */
    }
    
    /* Container for message time and speaker button */
    .message-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 6px;
        padding: 0 5px;
        min-height: 28px; /* Ensure consistent height */
    }
    
    /* Responsive design for smaller screens */
    @media (max-width: 768px) {
        .speaker-btn {
            width: 24px;
            height: 24px;
            font-size: 10px;
        }
        
        .message-footer {
            min-height: 24px;
        }
    }
    
    .typing-indicator {
        display: none;
        padding: 16px 24px;
        color: #5f6368;
        font-style: italic;
        background: #ffffff;
        border-radius: 18px;
        margin: 10px 0;
        max-width: 85%;
        width: fit-content;
        border-bottom-left-radius: 4px;
        /* box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); */
        align-self: flex-start;
        font-weight: 375;
    }
    
    .typing-text {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        color: #8d8d8d;
        background: white;
        border: None;
        font-weight: 375;
        font-family: 'Inter', sans-serif;
        letter-spacing: -0.01em;
    }
    
    .thinking-dots {
        display: inline-flex;
        gap: 2px;
    }
    
    .thinking-dots .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background-color: #949494;
        animation: wave 1.4s infinite ease-in-out;
        opacity: 0.4;
    }
    
    .thinking-dots .dot:nth-child(1) {
        animation-delay: 0s;
    }
    
    .thinking-dots .dot:nth-child(2) {
        animation-delay: 0.2s;
    }
    
    .thinking-dots .dot:nth-child(3) {
        animation-delay: 0.4s;
    }
    
    @keyframes wave {
        0%, 60%, 100% {
            transform: translateY(0);
            opacity: 0.4;
        }
        30% {
            transform: translateY(-10px);
            opacity: 1;
        }
    }
    
    .typing-indicator.show {
        display: block;
        animation: slideInUp 0.3s ease-out;
    }
    
    @keyframes slideInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* === KHUNG NH·∫¨P LI·ªÜU === */
    .chat-input-container {
        padding: 10px;
        width: 99%;
        margin: 0 auto 6px auto;
        background: #ffffff;
        border-radius: 20px;
        border: 2px solid #10a37f;
    }

    .input-wrapper {
        display: flex;
        align-items: center;
        background: #ffffff;
        /* border: 2px solid #e0e0e0; */
        border-radius: 28px;
        padding: 2px 10px 2px 20px;
        transition: box-shadow 0.2s;
        font-size: 20px;
    }
    /* .input-wrapper:focus-within { */
        /* border-color: #10a37f; */
        /* box-shadow: 0 0 0 3px rgba(16, 163, 127, 0.15); */
    /* } */
    
    .chat-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-size: 1rem;
        padding: 8px 0;
        font-family: 'Inter', sans-serif;
        font-weight: 350;
        letter-spacing: -0.01em;
    }
    
    .send-btn {
        background: #10a37f; /* Xanh Google */
        color: white;
        border: none;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        margin-left: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    
    .send-btn:hover {
        background: rgb(30,123,94);
    }
    
    .disclaimer {
        text-align: center;
        font-size: 0.75rem;
        color: #5f6368;
        padding-top: 12px;
    }
    
    /* Speaker button for text-to-speech */
    .speaker-btn {
        background: rgba(255, 255, 255);
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.7;
        transition: all 0.2s ease;
        color: #10a37f;
        font-size: 12px;
        margin-left: 8px;
        flex-shrink: 0; /* Don't shrink when space is limited */
    }
    
    .speaker-btn:hover {
        opacity: 1;
        background: rgba(16, 163, 127, 0.2);
        transform: scale(1.1);
    }
    
    .speaker-btn.playing {
        background: #10a37f;
        color: white;
        animation: pulse 1.5s infinite;
    }
    
    .speaker-btn.loading {
        opacity: 0.5;
        /* cursor: not-allowed; */
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    /* === MARKDOWN STYLING === */
    .message-content h1,
    .message-content h2,
    .message-content h3,
    .message-content h4,
    .message-content h5,
    .message-content h6 {
        margin: 16px 0 8px 0;
        font-weight: 600;
        line-height: 1.25;
    }
    
    .message-content h2 {
        font-size: 1.5em;
        border-bottom: 1px solid #e1e5e9;
        padding-bottom: 8px;
    }
    
    .message-content h3 {
        font-size: 1.25em;
    }
    
    .message-content p {
        margin: 8px 0;
        line-height: 1.6;
    }
    
    .message-content ul,
    .message-content ol {
        margin: 8px 0;
        padding-left: 24px;
    }
    
    .message-content li {
        margin: 4px 0;
        line-height: 1.5;
    }
    
    .message-content code {
        background: #f6f8fa;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.9em;
        color: #d73a49;
    }
    
    .message-content pre {
        background: #f6f8fa;
        padding: 12px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 12px 0;
        border-left: 4px solid #10a37f;
    }
    
    .message-content pre code {
        background: none;
        padding: 0;
        color: #24292e;
    }
    
    .message-content blockquote {
        margin: 12px 0;
        padding: 0 16px;
        border-left: 4px solid #dfe2e5;
        color: #6a737d;
        background: #f8f9fa;
        border-radius: 0 6px 6px 0;
    }
    
    .message-content table {
        border-collapse: collapse;
        width: 100%;
        margin: 12px 0;
    }
    
    .message-content th,
    .message-content td {
        border: 1px solid #dfe2e5;
        padding: 8px 12px;
        text-align: left;
    }
    
    .message-content th {
        background: #f6f8fa;
        font-weight: 600;
    }
    
    .message-content hr {
        border: none;
        height: 2px;
        background: #e1e5e9;
        margin: 20px 0;
    }
    
    .message-content strong {
        font-weight: 600;
        color: #24292e;
    }
    
    .message-content em {
        font-style: italic;
    }
    
    .message-content a {
        color: #0366d6;
        text-decoration: none;
    }
    
    .message-content a:hover {
        text-decoration: underline;
    }


.upload-date {
    border: none;
    background: none;
    color: #10a37f;
    font-size: 0.75rem;
    transition: none;
    margin-left: 0;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    white-space: nowrap;
}

    .upload-date:hover{
        background: #10a37f;
        color: white;
        border-radius: 10px;
    }
    .upload-date:hover .fa-calendar {
        color: white !important;
    }
    
    .upload-date-text {
        margin-left: 0;
        display: inline;
        vertical-align: middle;
    }

    .studio-panel {
        width: 20%;
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: #ffffff;
        border-radius: 20px;
    }
    .studio-header {
        font-size: 20px;
        font-weight: 375;
        text-align: center;
        color: #10a37f;
        margin-bottom: 0px;
        padding: 5px;
        border-bottom: 1px solid #10a37f;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 35px; /* Match source-header height exactly */
        box-sizing: border-box;
    }
    .studio-collapse-btn {
        position: absolute;
        left: 10px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        padding: 5px;
        transition: all 0.2s;
        color: #10a37f;
    }
    .studio-panel.collapsed {
        width: 50px;
        min-width: 50px;
    }
    .studio-panel.collapsed .studio-header {
        writing-mode: vertical-lr;
        text-orientation: mixed;
        font-size: 0;
        height: 3%;
        justify-content: center;
        border-bottom: none;
        padding: 0;
    }
    .studio-panel.collapsed .studio-header::before {
        content: "";
        font-size: 0;
    }
    .studio-panel.collapsed .studio-body {
        display: none;
    }
    .studio-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 16px;
        gap: 10px;
    }
    .studio-note-textarea {
        width: 100%;
        height: 180px;
        border-radius: 12px;
        padding: 12px;
        font-size: 1rem;
        font-weight: 375;
        font-family: 'Inter', sans-serif;
        resize: vertical;
        margin-bottom: 10px;
        background: #f2f3f2;
        border: 2px solid #10a37f;
        color: #333;
        /* box-sizing: border-box; */
        transition: border-color 0.2s;
    }
    .studio-note-textarea:focus {
        border-color: rgb(30,123,94);
        outline: none;
    }
    .studio-note-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        height: min-content;
    }
    .studio-save-btn {
        background: #10a37f;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.2s;
    }
    .studio-save-btn:hover {
        background: rgb(30,123,94);
    }
    /* ...existing code... */

    /* Pin button for saving messages */
    .pin-btn {
        background: rgba(255, 255, 255);
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.7;
        transition: all 0.2s ease;
        color: #10a37f;
        font-size: 12px;
        margin-left: 8px;
        flex-shrink: 0;
    }
    
    .pin-btn:hover {
        opacity: 1;
        background: rgba(16, 163, 127, 0.2);
        transform: scale(1.1);
    }
    
    .pin-btn.pinned {
        background: #ffc107;
        color: white;
        opacity: 1;
    }
    
    .pin-btn.pinned:hover {
        background: #e0a800;
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    /* Studio Panel Tab System */
    .studio-tabs {
        display: flex;
        border-radius: 2px;
        margin-bottom: 2px;
        overflow: hidden;
    }
    
    .studio-tab {
        flex: 1;
        border: none;
        padding: 1px;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 375;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        position: relative;
        background: #10a37f;
        color: white;
        border-radius: 20px;
    }
    
    .studio-tab-content {
        display: none;
        height: 100%;
        flex-direction: column;
        border-radius: 10px;
        border: #10a37f solid 1px;
    }
    
    .studio-saved-counter {
        background: #ffc107;
        color: #333;
        border-radius: 10px;
        padding: 2px 6px;
        font-size: 0.7rem;
        font-weight: bold;
        margin-left: 4px;
    }
    
    /* Saved Messages in Studio */
    .studio-saved-messages {
        flex: 1;
        overflow-y: auto;
        padding: 0;
        margin-bottom: 12px;
    }
    
    .studio-empty-state {
        text-align: center;
        color: #666;
        padding: 30px 15px;
    }
    
    .studio-empty-state i {
        font-size: 2rem;
        margin-bottom: 10px;
        opacity: 0.3;
        display: block;
    }
    
    .studio-saved-item {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 8px;
        transition: all 0.2s ease;
        position: relative;
    }
    
    .studio-saved-item:hover {
        background: #e9ecef;
        border-color: #10a37f;
    }
    
    .studio-saved-content {
        font-size: 0.85rem;
        line-height: 1.4;
        margin-bottom: 8px;
        max-height: 100px;
        overflow-y: auto;
        word-wrap: break-word;
    }
    
    .studio-saved-time {
        font-size: 0.7rem;
        color: #666;
        margin-bottom: 6px;
    }
    
    .studio-saved-actions {
        display: flex;
        gap: 6px;
        justify-content: flex-end;
    }
    
    .studio-saved-actions button {
        background: none;
        border: none;
        padding: 4px 6px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7rem;
        transition: all 0.2s;
    }
    
    .studio-saved-actions .btn-copy {
        color: #10a37f;
    }
    
    .studio-saved-actions .btn-copy:hover {
        background: #10a37f;
        color: white;
    }
    
    .studio-saved-actions .btn-delete {
        color: #dc3545;
    }
    
    .studio-saved-actions .btn-delete:hover {
        background: #dc3545;
        color: white;
    }
    
    .studio-clear-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        margin: 0 auto;
    }
    
    .studio-clear-btn:hover {
        background: #c82333;
    }
    
    .studio-clear-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
    }

    .btn-pin-note {
    background: #6c757d; /* M√†u x√°m */
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.2s;
    margin-right: 10px; /* T·∫°o kho·∫£ng c√°ch v·ªõi n√∫t L∆∞u */
    }

    .btn-pin-note:hover {
        background: #5a6268;
    }

    /* Style cho n√∫t Ghim khi ƒë∆∞·ª£c k√≠ch ho·∫°t (active) */
    .btn-pin-note.active {
        background: #ffc107; /* M√†u v√†ng */
        color: #212529;
    }

    /* Style cho ghi ch√∫ ƒë∆∞·ª£c ghim trong danh s√°ch */
    .studio-note-item.pinned {
        background-color: #fffbe6; /* N·ªÅn m√†u v√†ng nh·∫°t */
        border-left: 4px solid #ffc107;
    }

    .studio-note-item.pinned .studio-note-pin-icon {
        display: inline-block; /* Hi·ªán icon ghim */
        color: #ffc107;
        margin-right: 8px;
    }

    /* CSS cho tab Ghi ch√∫ trong Studio */
    #notesTab {
        position: relative; /* C·∫ßn thi·∫øt ƒë·ªÉ ƒë·ªãnh v·ªã n√∫t + */
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    /* CSS cho danh s√°ch c√°c ghi ch√∫ */
    .studio-notes-list {
        flex-grow: 1; /* Cho ph√©p danh s√°ch l·∫•p ƒë·∫ßy kh√¥ng gian c√≤n l·∫°i */
        overflow-y: auto; /* Th√™m thanh cu·ªôn khi danh s√°ch d√†i */
        padding: 10px;
    }

    /* CSS cho t·ª´ng m·ª•c ghi ch√∫ trong danh s√°ch */
    .studio-note-item {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-left: 4px solid #10a37f; /* M√†u m·∫∑c ƒë·ªãnh */
        padding: 12px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 375;
    }

    .studio-note-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        background-color: #e2fff2;
    }

    .studio-note-title {
        font-weight: 500;
        margin-bottom: 6px;
        display: flex;
        align-items: center;
    }

    .studio-note-content {
        font-size: 0.9rem;
        color: #495057;
        white-space: pre-wrap; /* Hi·ªÉn th·ªã xu·ªëng d√≤ng */
        word-break: break-word;
    }

    .studio-note-time {
        font-size: 0.75rem;
        color: #6c757d;
        margin-top: 8px;
    }

    .studio-note-actions {
        display: flex;
        gap: 10px;
        margin-top: 10px;
    }
    .studio-note-actions button {
        background: none;
        border: none;
        cursor: pointer;
        color: #6c757d;
        font-size: 0.8rem;
    }
    .studio-note-actions button:hover {
        color: #10a37f;
    }


    /* CSS cho n√∫t Th√™m m·ªõi (+) */
    .studio-add-btn {
        position: absolute; /* ƒê·ªãnh v·ªã tuy·ªát ƒë·ªëi so v·ªõi #notesTab */
        bottom: 20px;
        right: 20px;
        background-color: #10a37f;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(16, 163, 127, 0.4);
        transition: all 0.2s ease;
        z-index: 10;
    }

    .studio-add-btn:hover {
        transform: scale(1.1);
        background-color: #0d8a6b;
    }

    /* Style cho n√∫t ghim file */
    .btn-pin-file {
        background: none;
        border: none;
        color: #adb5bd; /* M√†u x√°m nh·∫°t m·∫∑c ƒë·ªãnh */
        cursor: pointer;
        font-size: 0.9rem;
        padding: 5px;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        transition: all 0.2s;
        position: absolute; /* ƒê·ªãnh v·ªã n√∫t ghim */
        top: 8px;
        right: 8px;
    }

    .btn-pin-file:hover {
        background-color: #e9ecef;
        color: #343a40;
    }

    /* Style cho n√∫t ghim khi ƒë∆∞·ª£c k√≠ch ho·∫°t */
    .btn-pin-file.active {
        color: #ffc107; /* M√†u v√†ng khi ƒë∆∞·ª£c ghim */
    }

    /* Style cho ghi ch√∫ ƒë∆∞·ª£c ghim trong danh s√°ch */
    .studio-note-item.pinned {
        background-color: #fffbe6; /* N·ªÅn m√†u v√†ng nh·∫°t */
        border-left: 4px solid #ffc107;
    }

    /* Style cho icon ghim b√™n trong ti√™u ƒë·ªÅ */
    .studio-note-item.pinned .studio-note-pin-icon {
        display: inline-block; /* Ch·ªâ hi·ªán icon khi note ƒë∆∞·ª£c ghim */
        color: #ffc107;
        margin-right: 8px;
        font-size: 0.8em; /* K√≠ch th∆∞·ªõc icon nh·ªè h∆°n m·ªôt ch√∫t */
    }
</style>

<div class="notebook-layout">
    <!-- Thanh th√¥ng b√°o -->
    <div id="notificationBar" class="notification-bar">
        <div class="notification-content">
            <div class="notification-icon">
                <i class="fas fa-info-circle"></i>
            </div>
            <div class="notification-message">
                <div class="notification-text"></div>
                <div class="notification-details"></div>
            </div>
        </div>
        <button class="notification-close" onclick="hideNotification()">&times;</button>
        <div class="notification-progress"></div>
    </div>

    <div class="source-panel">
        <h2 class="source-header">
            T√†i li·ªáu ngu·ªìn
            <button class="collapse-btn" style="color: #10a37f;" onclick="toggleSourcePanel()">
                <i class="fas fa-chevron-left"></i>
            </button>
        </h2>
        <div class="source-item" id="userDatabaseList">
            <div class="loading-indicator" id="loadingIndicator">
                <i class="fas fa-spinner fa-spin"></i> ƒêang t·∫£i d·ªØ li·ªáu...
            </div>
        </div>    
        <div class="source-actions">
            <button class="btn-refresh" onclick="loadUserDatabase()">
                <i class="fas fa-refresh"></i> L√†m m·ªõi
            </button>
        </div>
    </div>

    <div class="chat-panel" data-username="{{ user.username }}">
        <h2 class = 'chat-panel-header'>
            Cu·ªôc tr√≤ chuy·ªán
        </h2>
        <div class="chat-body" id="chatBody">
            <div class="message bot">
                <div class="message-content">
                    Xin ch√†o <strong>{{ user.first_name }}</strong>, T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n? 
                    
                </div>
                <div class="message-time">V·ª´a xong</div>
            </div>
        </div>
        <!-- Hidden data for JavaScript -->
        <script type="application/json" id="user-data">
            {
                "username": "{{ user.username }}",
                "first_name": "{{ user.first_name }}",
                "is_authenticated": {% if user.is_authenticated %}true{% else %}false{% endif %}
            }
        </script>
        <div class="typing-indicator" id="typingIndicator">
            <div class="typing-text">
                ƒêang suy nghƒ© v√† tr·∫£ l·ªùi
                <div class="thinking-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        <div class="chat-input-container">
            <div class="input-wrapper">
                <input 
                    type="text" 
                    class="chat-input" 
                    id="messageInput" 
                    placeholder="H·ªèi b·∫•t c·ª© ƒëi·ªÅu g√¨..."
                    onkeypress="handleKeyPress(event)"
                >
                <button class="send-btn" onclick="sendMessage()">
                    <i class="fas fa-arrow-up"></i>
                </button>
            </div>
            <div class="disclaimer">
                <small>
                    <i class="fas fa-info-circle me-1"></i>
                    WoxionChat c√≥ th·ªÉ m·∫Øc l·ªói, h√£y ki·ªÉm tra nh·ªØng n·ªôi dung quan tr·ªçng
                </small>
            </div>
        </div>
    </div>

    <!-- Studio Panel for user notes (ph√≠a ph·∫£i chat-panel) -->
    <div class="studio-panel" id="studioPanel">
        <div class="studio-header">
            Studio
            <button class="studio-collapse-btn" onclick="toggleStudioPanel()">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <div class="studio-body">
            <div class="studio-tabs">
                <button class="studio-tab" data-tab="notes" onclick="switchStudioTab('notes')">
                    <i class="fas fa-sticky-note"></i>
                    Ghi ch√∫
                </button>
            </div>
            
            <!-- Notes Tab -->
            <div class="studio-tab-content active" id="notesTab" style="position:relative;">
                <button class="studio-add-btn" id="studioAddBtn" title="Th√™m ghi ch√∫ m·ªõi" onclick="showAddNoteForm()">
                    <i class="fas fa-plus"></i>
                </button>
                
                <div class="studio-notes-list" id="studioNotesList">
                    </div>

                <div class="studio-empty-state" id="studioNotesEmpty" style="display: none;">
                    <i class="fas fa-sticky-note"></i>
                    <p>Ch∆∞a c√≥ ghi ch√∫ n√†o</p>
                    <small>Nh·∫•n d·∫•u <b>+</b> ƒë·ªÉ th√™m ghi ch√∫ m·ªõi</small>
                </div>
                <!-- Add/Edit Note Modal -->
                <div class="modal" id="studioNoteModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <span id="studioNoteModalTitle">Th√™m ghi ch√∫</span>
                            <button class="modal-close" onclick="closeNoteModal()">&times;</button>
                        </div>
                        <div class="form-group">
                            <label for="noteTitle">Ti√™u ƒë·ªÅ</label>
                            <input type="text" id="noteTitle" maxlength="100" placeholder="Ti√™u ƒë·ªÅ ghi ch√∫ (t√πy ch·ªçn)">
                        </div>
                        <div class="form-group">
                            <label for="noteContent">N·ªôi dung</label>
                            <textarea id="noteContent" rows="5" maxlength="2000" placeholder="Nh·∫≠p n·ªôi dung ghi ch√∫..."></textarea>
                        </div>
                        <div class="studio-note-footer">
                            <button class="btn-pin-note" id="pinNoteBtn" onclick="togglePinState()">
                                <i class="fas fa-thumbtack"></i> Ghim
                            </button>
                            <button class="studio-save-btn" id="saveNoteBtn" onclick="saveNote()">L∆∞u</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Saved Messages Tab -->
            <div class="studio-tab-content" id="savedTab">
                <div class="studio-saved-messages" id="studioSavedMessages">
                    <div class="studio-empty-state">
                        <i class="fas fa-thumbtack"></i>
                        <p>Ch∆∞a c√≥ tin nh·∫Øn n√†o ƒë∆∞·ª£c ghim</p>
                        <small>Nh·∫•p v√†o bi·ªÉu t∆∞·ª£ng ghim üìå ·ªü tin nh·∫Øn bot ƒë·ªÉ l∆∞u l·∫°i</small>
                    </div>
                </div>
                <div class="studio-saved-actions">
                    <button class="studio-clear-btn" onclick="clearAllSavedMessages()" disabled>
                        <i class="fas fa-trash"></i>
                        X√≥a t·∫•t c·∫£
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// ========== Studio Notes CRUD ========== //
let notes = [];
let editingNoteId = null;

function getCSRFToken() {
    // L·∫•y CSRF token t·ª´ cookie
    return document.cookie.split('; ').find(row => row.startsWith('csrftoken='))?.split('=')[1];
}

async function fetchNotes() {
    try {
        const user = getCurrentUsername(); 
        if (!user) {
            console.warn('Ch∆∞a x√°c ƒë·ªãnh ng∆∞·ªùi d√πng, kh√¥ng th·ªÉ t·∫£i ghi ch√∫.');
            return;
        }

        const res = await fetch(`/takenote/notes/?user=${encodeURIComponent(user)}`, {
            headers: { 'X-CSRFToken': getCSRFToken() }
        });

        if (!res.ok) throw new Error('Kh√¥ng th·ªÉ t·∫£i ghi ch√∫ t·ª´ m√°y ch·ªß');
        
        const data = await res.json();
        notes = data || []; 
        renderNotes(); // G·ªçi h√†m render sau khi c√≥ d·ªØ li·ªáu
    } catch (e) {
        showErrorNotification('L·ªói t·∫£i ghi ch√∫', e.message);
        console.error("L·ªói fetchNotes:", e);
    }
}

let currentNoteIsPinned = false;

function renderNotes() {
    const list = document.getElementById('studioNotesList');
    const emptyState = document.getElementById('studioNotesEmpty');
    list.innerHTML = ''; 

    if (!notes || notes.length === 0) {
        emptyState.style.display = 'block';
        return;
    }

    emptyState.style.display = 'none';

    notes.forEach(note => {
        const noteId = note.id || note._id || note.pk;
        const item = document.createElement('div');
        
        // ---- PH·∫¶N QUAN TR·ªåNG B·∫ÆT ƒê·∫¶U ----

        // 1. Th√™m class 'pinned' v√†o th·∫ª div ch√≠nh n·∫øu note.is_pinned l√† true
        item.className = `studio-note-item ${note.is_pinned ? 'pinned' : ''}`;
        item.setAttribute('onclick', `editNote('${noteId}')`);

        item.innerHTML = `
            <div class="studio-note-title">
                
                ${note.is_pinned ? '<span class="studio-note-pin-icon"><i class="fas fa-thumbtack"></i></span>' : ''}
                
                ${escapeHtml(note.title) || '(Kh√¥ng ti√™u ƒë·ªÅ)'}
            </div>
            <div class="studio-note-content">${escapeHtml(note.content)}</div>
            <div class="studio-note-time">${formatNoteTime(note.created_at)}</div>
            <div class="studio-note-actions">
                <button onclick="event.stopPropagation(); editNote('${noteId}')"><i class='fas fa-edit'></i> S·ª≠a</button>
                <button onclick="event.stopPropagation(); deleteNote('${noteId}')"><i class='fas fa-trash'></i> X√≥a</button>
            </div>
        `;

        // ---- PH·∫¶N QUAN TR·ªåNG K·∫æT TH√öC ----

        list.appendChild(item);
    });
}

function togglePinState() {
    const pinBtn = document.getElementById('pinNoteBtn');
    currentNoteIsPinned = !currentNoteIsPinned; // ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i
    if (currentNoteIsPinned) {
        pinBtn.classList.add('active');
    } else {
        pinBtn.classList.remove('active');
    }
}

function showAddNoteForm() {
    editingNoteId = null;
    currentNoteIsPinned = false; // Reset tr·∫°ng th√°i ghim cho note m·ªõi
    document.getElementById('studioNoteModalTitle').innerText = 'Th√™m ghi ch√∫';
    document.getElementById('noteTitle').value = '';
    document.getElementById('noteContent').value = '';
    document.getElementById('pinNoteBtn').classList.remove('active'); // B·ªè active n√∫t ghim
    document.getElementById('studioNoteModal').style.display = 'block';
}

function closeNoteModal() {
    document.getElementById('studioNoteModal').style.display = 'none';
}

function editNote(id) {
    const note = notes.find(n => (n.id || n._id || n.pk) == id);
    if (!note) return;
    editingNoteId = id;
    currentNoteIsPinned = note.is_pinned; // Set tr·∫°ng th√°i ghim t·ª´ d·ªØ li·ªáu note
    document.getElementById('studioNoteModalTitle').innerText = 'S·ª≠a ghi ch√∫';
    document.getElementById('noteTitle').value = note.title || '';
    document.getElementById('noteContent').value = note.content || '';
    
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i active cho n√∫t ghim
    const pinBtn = document.getElementById('pinNoteBtn');
    if (currentNoteIsPinned) {
        pinBtn.classList.add('active');
    } else {
        pinBtn.classList.remove('active');
    }
    
    document.getElementById('studioNoteModal').style.display = 'block';
}

async function saveNote() {
    const title = document.getElementById('noteTitle').value.trim();
    const content = document.getElementById('noteContent').value.trim();
    if (!title || !title.trim()) {
        showWarningNotification('Ti√™u ƒë·ªÅ ghi ch√∫ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
        return;
    }

    try {
        const user = getCurrentUsername();
        if (!user) {
            showErrorNotification('L·ªói nghi√™m tr·ªçng', 'Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ng∆∞·ªùi d√πng.');
            return;
        }

        let res;
        const headers = {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        };
        
        // T·∫°o body request, g·ª≠i k√®m tr·∫°ng th√°i "is_pinned"
        const body = JSON.stringify({ 
            user: user, // user ch·ªâ c·∫ßn cho l√∫c t·∫°o m·ªõi, nh∆∞ng g·ª≠i c≈©ng kh√¥ng sao
            title: title, 
            content: content,
            is_pinned: currentNoteIsPinned // <-- G·ª≠i tr·∫°ng th√°i ghim
        });

        if (editingNoteId) {
            res = await fetch(`/takenote/notes/${editingNoteId}/edit/`, {
                method: 'PUT',
                headers,
                body: body
            });
        } else {
            const addBody = JSON.stringify({
                user: user,
                title: title,
                content: content,
                is_pinned: currentNoteIsPinned
            });
            res = await fetch('/takenote/notes/add/', {
                method: 'POST',
                headers,
                body: body
            });
        }

        if (!res.ok) {
             const errorData = await res.json();
             throw new Error(errorData.error || 'L∆∞u ghi ch√∫ th·∫•t b·∫°i');
        }
        
        closeNoteModal();
        await fetchNotes(); // T·∫£i l·∫°i danh s√°ch, c√°c note ghim s·∫Ω l√™n ƒë·∫ßu
        showSuccessNotification(editingNoteId ? 'ƒê√£ c·∫≠p nh·∫≠t ghi ch√∫!' : 'ƒê√£ l∆∞u ghi ch√∫!');
        
    } catch (e) {
        showErrorNotification('L·ªói khi l∆∞u ghi ch√∫', e.message);
        console.error("L·ªói saveNote:", e);
    }
}

async function deleteNote(id) {
    if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ghi ch√∫ n√†y?')) return;
    try {
        // S·ª¨A: URL cho vi·ªác x√≥a (DELETE) ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
        const res = await fetch(`/takenote/notes/${id}/delete/`, {
            method: 'DELETE',
            headers: { 'X-CSRFToken': getCSRFToken() }
        });
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.error || 'X√≥a ghi ch√∫ th·∫•t b·∫°i');
        }
        await fetchNotes(); // T·∫£i l·∫°i danh s√°ch ghi ch√∫
        showSuccessNotification('ƒê√£ x√≥a ghi ch√∫!');
    } catch (e) {
        showErrorNotification('L·ªói x√≥a ghi ch√∫', e.message);
        console.error("L·ªói deleteNote:", e);
    }
}

function formatNoteTime(dt) {
    if (!dt) return '';
    const d = new Date(dt);
    if (isNaN(d)) return dt;
    return d.toLocaleString('vi-VN', { hour12: false });
}
function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'})[m];
    });
}
// ƒê√≥ng modal khi click ngo√†i
window.onclick = function(event) {
    const modal = document.getElementById('studioNoteModal');
    if (event.target == modal) modal.style.display = 'none';
}

// Studio Panel collapse logic gi·ªØ nguy√™n
function toggleStudioPanel() {
    const panel = document.getElementById('studioPanel');
    const btnIcon = panel.querySelector('.studio-collapse-btn i');
    if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        btnIcon.classList.remove('fa-chevron-left');
        btnIcon.classList.add('fa-chevron-right');
    } else {
        panel.classList.add('collapsed');
        btnIcon.classList.remove('fa-chevron-right');
        btnIcon.classList.add('fa-chevron-left');
    }
}

// T·∫£i ghi ch√∫ khi trang t·∫£i xong
document.addEventListener('DOMContentLoaded', fetchNotes);
let userDatabaseCache = [];
let notificationTimeout = null;
let ongoingChatRequest = null; // Track ongoing chat requests
let heartbeatInterval = null;  // Keep connection alive

// === NOTIFICATION BAR FUNCTIONS ===

function toggleSourcePanel() {
    const sourcePanel = document.querySelector('.source-panel');
    const collapseBtn = document.querySelector('.collapse-btn i');
    
    if (sourcePanel.classList.contains('collapsed')) {
        // Expand the panel
        sourcePanel.classList.remove('collapsed');
        collapseBtn.classList.remove('fa-chevron-right');
        collapseBtn.classList.add('fa-chevron-left');
        
        // Show notification
        // showInfoNotification('üìñ ƒê√£ m·ªü r·ªông panel t√†i li·ªáu', 'Panel t√†i li·ªáu ƒë√£ ƒë∆∞·ª£c m·ªü r·ªông');
    } else {
        // Collapse the panel
        sourcePanel.classList.add('collapsed');
        collapseBtn.classList.remove('fa-chevron-left');
        collapseBtn.classList.add('fa-chevron-right');
        
        // Show notification
        //showInfoNotification('üìñ ƒê√£ thu g·ªçn panel t√†i li·ªáu', 'Panel t√†i li·ªáu ƒë√£ ƒë∆∞·ª£c thu g·ªçn ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian');
    }
}

function showNotification(message, type = 'info', details = '', duration = 5000) {
    const notificationBar = document.getElementById('notificationBar');
    if (!notificationBar) {
        console.error('[Notification] notificationBar element not found!');
        return;
    }
    const notificationText = notificationBar.querySelector('.notification-text');
    const notificationDetails = notificationBar.querySelector('.notification-details');
    const notificationIcon = notificationBar.querySelector('.notification-icon i');
    const notificationProgress = notificationBar.querySelector('.notification-progress');
    console.log('[Notification] showNotification called', { message, type, details, duration });
    if (!notificationText) console.warn('[Notification] .notification-text not found!');
    if (!notificationDetails) console.warn('[Notification] .notification-details not found!');
    if (!notificationIcon) console.warn('[Notification] .notification-icon i not found!');
    if (!notificationProgress) console.warn('[Notification] .notification-progress not found!');
    // Clear previous timeout
    if (notificationTimeout) {
        clearTimeout(notificationTimeout);
    }
    // Remove existing classes
    notificationBar.classList.remove('success', 'error', 'warning', 'info');
    // Set content
    if (notificationText) notificationText.innerHTML = message;
    if (notificationDetails) notificationDetails.innerHTML = details;
    // Set icon and type
    let iconClass = 'fas fa-info-circle';
    switch (type) {
        case 'success':
            iconClass = 'fas fa-check-circle';
            break;
        case 'error':
            iconClass = 'fas fa-exclamation-triangle';
            break;
        case 'warning':
            iconClass = 'fas fa-exclamation-circle';
            break;
        case 'info':
        default:
            iconClass = 'fas fa-info-circle';
            break;
    }
    if (notificationIcon) notificationIcon.className = iconClass;
    notificationBar.classList.add(type);
    // Reset progress animation
    if (notificationProgress) {
        notificationProgress.style.animation = 'none';
        notificationProgress.offsetHeight; // Force reflow
        notificationProgress.style.animation = `notificationProgress ${duration}ms linear forwards`;
    }
    // Show notification
    notificationBar.classList.add('show');
    console.log('[Notification] Notification shown:', { type, message });
    // Auto hide after duration
    notificationTimeout = setTimeout(() => {
        hideNotification();
    }, duration);
}

function hideNotification() {
    const notificationBar = document.getElementById('notificationBar');
    if (notificationBar) {
        notificationBar.classList.remove('show');
        console.log('[Notification] Notification hidden');
    } else {
        console.warn('[Notification] Tried to hide notification but notificationBar not found!');
    }
    if (notificationTimeout) {
        clearTimeout(notificationTimeout);
        notificationTimeout = null;
    }
}

function showSuccessNotification(message, details = '') {
    showNotification(message, 'success', details);
}

function showErrorNotification(message, details = '') {
    showNotification(message, 'error', details);
}

function showWarningNotification(message, details = '') {
    showNotification(message, 'warning', details);
}

function showInfoNotification(message, details = '') {
    showNotification(message, 'info', details);
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Page loaded, starting initialization...');
    
    // Debug current username
    const currentUsername = getCurrentUsername();
    console.log('üë§ Current username detected:', currentUsername);
    
    // Debug all elements
    const loadingIndicator = document.getElementById('loadingIndicator');
    const userDatabaseList = document.getElementById('userDatabaseList');
    const chatPanel = document.querySelector('.chat-panel');
    
    console.log('üîç DOM elements check:');
    console.log('  - loadingIndicator:', loadingIndicator);
    console.log('  - userDatabaseList:', userDatabaseList);
    console.log('  - chatPanel:', chatPanel);
    
    // Initialize saved messages
    updateStudioSavedCounter();
    
    // Update pin button states for existing messages
    const savedMessages = getSavedMessages();
    savedMessages.forEach(msg => {
        const messageDiv = document.getElementById(msg.id);
        if (messageDiv) {
            const pinBtn = messageDiv.querySelector('.pin-btn');
            if (pinBtn) {
                pinBtn.classList.add('pinned');
                pinBtn.title = 'B·ªè ghim tin nh·∫Øn';
            }
        }
    });
    
    console.log('üìå Studio saved messages initialized:', savedMessages.length, 'messages');
    
    // Add welcome message explaining WoxionChat integration
    setTimeout(() => {
    }, 500);
    
    // Start heartbeat to maintain connection from page load
    startHeartbeat();
    console.log('üíì Heartbeat started to maintain unlimited connection');
    
    // Check server timeout settings
    checkServerTimeoutSettings();
    
    // Notify user about unlimited timeout feature
    setTimeout(() => {
        showSuccessNotification(
            'üöÄ <strong>Ch·∫ø ƒë·ªô kh√¥ng gi·ªõi h·∫°n th·ªùi gian ƒë√£ k√≠ch ho·∫°t!</strong>',
            'üí° Chat c·ªßa b·∫°n s·∫Ω kh√¥ng b·ªã timeout, c√≥ th·ªÉ ch·ªù ph·∫£n h·ªìi AI bao l√¢u c≈©ng ƒë∆∞·ª£c. Heartbeat ƒëang duy tr√¨ k·∫øt n·ªëi.'
        );
    }, 2000);
    
    // Notify about TTS feature
    setTimeout(() => {
        showInfoNotification(
            'üîä <strong>Text-to-Speech v·ªõi FPT.AI ƒë√£ s·∫µn s√†ng!</strong>',
            'üí¨ Nh·∫•p v√†o bi·ªÉu t∆∞·ª£ng loa üîä ·ªü g√≥c ph·∫£i m·ªói tin nh·∫Øn ƒë·ªÉ nghe gi·ªçng ƒë·ªçc ch·∫•t l∆∞·ª£ng cao b·∫±ng ti·∫øng Vi·ªát!'
        );
    }, 4000);
    
    // Notify about Markdown support
    setTimeout(() => {
        showInfoNotification(
            'üìù <strong>H·ªó tr·ª£ ƒë·ªãnh d·∫°ng Markdown!</strong>',
            '‚ú® WoxionChat gi·ªù ƒë√¢y s·∫Ω tr·∫£ l·ªùi v·ªõi ƒë·ªãnh d·∫°ng Markdown ƒë·∫πp m·∫Øt, bao g·ªìm ti√™u ƒë·ªÅ, danh s√°ch, b·∫£ng, code blocks v√† nhi·ªÅu h∆°n n·ªØa!'
        );
    }, 6000);
    
    // Notify about Pin Messages feature
    setTimeout(() => {
        showInfoNotification(
            'üìå <strong>Ch·ª©c nƒÉng ghim tin nh·∫Øn trong Studio!</strong>',
            'üíæ Nh·∫•p v√†o bi·ªÉu t∆∞·ª£ng ghim üìå ·ªü tin nh·∫Øn bot ƒë·ªÉ l∆∞u v√†o Studio. Ph√≠m t·∫Øt: <kbd>Ctrl+Shift+S</kbd> ƒë·ªÉ m·ªü tab "ƒê√£ ghim"!'
        );
    }, 8000);
    
    // Load user database
    loadUserDatabase();
});

// User Database Functions
async function loadUserDatabase() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const userDatabaseList = document.getElementById('userDatabaseList');
    
    console.log('üîç Loading user database...');
    loadingIndicator.style.display = 'block';
    
    try {
        // Get current user's username first
        const currentUsername = getCurrentUsername();
        console.log('üë§ Current username:', currentUsername);
        
        // Load all user database entries
        console.log('üåê Making API request to /api/user-database/');
        const response = await fetch('/api/user-database/');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        console.log('üìä API Response:', result);
        
        if (result.success) {
            userDatabaseCache = result.data;
            console.log('üíæ Cached data:', userDatabaseCache);
            console.log('üìä Total entries received:', userDatabaseCache.length);
            
            // Filter entries by current user's username
            const userSpecificData = filterByCurrentUser(result.data, currentUsername);
            console.log('üîç User-specific data for', currentUsername, ':', userSpecificData);
            
            displayUserDatabase(userSpecificData);
            
            // Auto-select user's data if available
            autoSelectUserData(currentUsername);
        } else {
            console.error('‚ùå API Error:', result);
            showError('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ng∆∞·ªùi d√πng: ' + (result.message || 'Unknown error'));
        }
    } catch (error) {
        console.error('‚ùå Error loading user database:', error);
        showError('L·ªói k·∫øt n·ªëi ƒë·∫øn server: ' + error.message);
    } finally {
        loadingIndicator.style.display = 'none';
    }
}

function getCurrentUsername() {
    // Try to get username from Django template context first
    try {
        const userDataScript = document.getElementById('user-data');
        if (userDataScript) {
            const userData = JSON.parse(userDataScript.textContent);
            console.log('üîç Found user data from script:', userData);
            if (userData.username) {
                return userData.username;
            }
        }
    } catch (e) {
        console.error('‚ö†Ô∏è Error parsing user data script:', e);
    }
    
    // Try to get username from Django template context or from page data
    const usernameElement = document.querySelector('[data-username]');
    if (usernameElement) {
        const username = usernameElement.getAttribute('data-username');
        console.log('üîç Found username from data attribute:', username);
        return username;
    }
    
    // Fallback: try to extract from welcome message or other sources
    const welcomeMessage = document.querySelector('.message-content strong');
    if (welcomeMessage) {
        const username = welcomeMessage.textContent || 'unknown_user';
        console.log('üîç Found username from welcome message:', username);
        return username;
    }
    
    // For testing, return a default username
    console.log('‚ö†Ô∏è No username found, using default: testuser');
    return 'testuser'; // Default for testing
}

function filterByCurrentUser(data, username) {
    console.log('üîç Filtering data for username:', username);
    console.log('üìä Total data entries:', data ? data.length : 0);
    
    if (!data || !username || username === 'unknown_user') {
        console.log('‚ö†Ô∏è No filtering applied, returning all data');
        return data || []; // Return all data if no specific username
    }
    
    // Debug: show all usernames in data
    if (data && data.length > 0) {
        const usernames = data.map(entry => entry.uploader_username);
        console.log('üìã Available usernames in data:', [...new Set(usernames)]);
        
        // Debug: show detailed info for each entry
        data.forEach((entry, index) => {
            console.log(`üìÑ Entry ${index + 1}:`, {
                uploader_username: entry.uploader_username,
                source_file: entry.source_file,
                filename: entry.file_data?.filename,
                has_source_file: !!entry.source_file,
                source_file_type: typeof entry.source_file
            });
        });
    }
    
    // Filter entries where uploader_username matches current user
    const filtered = data.filter(entry => {
        const match = entry.uploader_username === username;
        console.log(`üîç Checking entry: ${entry.uploader_username} === ${username} ? ${match}`);
        if (match) {
            console.log(`‚úÖ Matched entry:`, {
                uploader_username: entry.uploader_username,
                source_file: entry.source_file,
                filename: entry.file_data?.filename
            });
        }
        return match;
    });
    
    console.log('üéØ Filtered entries:', filtered.length);
    console.log('üìã Filtered data:', filtered);
    
    return filtered;
}

async function autoSelectUserData(username) {
    if (!username || username === 'unknown_user') return;
    
    console.log('üîç Auto-selecting data for username:', username);
    console.log('üìä Available data in cache:', userDatabaseCache);
    
    // Find user's data in cache
    const userData = userDatabaseCache.find(entry => entry.uploader_username === username);
    
    if (userData) {
        selectedUserData = userData;
        console.log('‚úÖ Found and selected data:', userData);
        
        // Highlight the entry if it exists in the display
        setTimeout(() => {
            const userEntry = document.querySelector(`[onclick="selectUserData('${username}', '${userData.source_file || 'unknown'}')"]`);
            if (userEntry) {
                userEntry.classList.add('selected');
            }
        }, 100);
        
        // **NEW: Auto-connect to document source**
        const sourceFile = userData.source_file || 'unknown';
        
        // Check if document is already chunked
        try {
            const chunkingStatus = await checkChunkingStatus(username);
            const isChunked = chunkingStatus[sourceFile] && chunkingStatus[sourceFile] > 0;
            
            if (!isChunked) {
                // Document is not chunked, automatically read it
                console.log('üìö Auto-reading document:', sourceFile);
                
                // Show notification about auto-connection
                showInfoNotification(
                    'üîó <strong>T·ª± ƒë·ªông k·∫øt n·ªëi t√†i li·ªáu ngu·ªìn...</strong>',
                    `ƒêang t·ª± ƒë·ªông ƒë·ªçc t√†i li·ªáu "${sourceFile}" ƒë·ªÉ b·∫°n c√≥ th·ªÉ chat ngay l·∫≠p t·ª©c!`
                );
                
                // Automatically read the document
                await readDocument(username, sourceFile);
                
                // Show success message
                setTimeout(() => {
                    showSuccessNotification(
                        '‚úÖ <strong>T·ª± ƒë·ªông k·∫øt n·ªëi th√†nh c√¥ng!</strong>',
                        'B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu chat v·ªÅ n·ªôi dung t√†i li·ªáu ngay b√¢y gi·ªù!'
                    );
                }, 2000);
                
            } else {
                // Document is already chunked
                console.log('‚úÖ Document already chunked, ready to use');
                showSuccessNotification(
                    'üîó <strong>T√†i li·ªáu ƒë√£ s·∫µn s√†ng!</strong>',
                    `T√†i li·ªáu "${sourceFile}" ƒë√£ ƒë∆∞·ª£c ƒë·ªçc v√† s·∫µn s√†ng ƒë·ªÉ chat!`
                );
            }
            
        } catch (error) {
            console.error('‚ùå Error during auto-connection:', error);
            showInfoNotification(
                '‚ö†Ô∏è <strong>Kh√¥ng th·ªÉ t·ª± ƒë·ªông k·∫øt n·ªëi</strong>',
                `T√†i li·ªáu "${sourceFile}" c√≥ th·ªÉ c·∫ßn ƒë∆∞·ª£c ƒë·ªçc th·ªß c√¥ng. Nh·∫•n n√∫t "ƒê·ªçc" n·∫øu c·∫ßn.`
            );
        }
        
        // Show auto-selection message (commented out original message)
        // addMessage(`üîç <strong>T·ª± ƒë·ªông t·∫£i d·ªØ li·ªáu c·ªßa b·∫°n:</strong><br>
        //            üë§ Ng∆∞·ªùi d√πng: ${userData.uploader_username}<br>
        //            üìÅ File: ${userData.source_file || userData.file_data?.filename || 'Kh√¥ng c√≥ t√™n'}<br>
        //            üìÖ Ng√†y t·∫£i: ${formatDate(userData.upload_date)}<br>
        //            üìù M√¥ t·∫£: ${userData.metadata.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}<br><br>
        //            üí° D·ªØ li·ªáu ƒë√£ s·∫µn s√†ng ƒë·ªÉ ph√¢n t√≠ch!<br>
        //            üéØ Th·ª≠ h·ªèi: "ph√¢n t√≠ch d·ªØ li·ªáu" ho·∫∑c "t√≥m t·∫Øt file"`, 'bot');
    } else {
        console.log('‚ö†Ô∏è No data found for username:', username);
        
        // Check if there's data for similar usernames
        const similarUsernames = userDatabaseCache
            .map(entry => entry.uploader_username)
            .filter(user => user.toLowerCase().includes(username.toLowerCase()) || username.toLowerCase().includes(user.toLowerCase()));
        
        let message = `üìã <strong>Ch∆∞a c√≥ d·ªØ li·ªáu:</strong><br><br>
                       Ch∆∞a t√¨m th·∫•y d·ªØ li·ªáu n√†o cho t√†i kho·∫£n <strong>${username}</strong>.<br><br>`;
        
        if (similarUsernames.length > 0) {
            message += `üîç <strong>T√¨m th·∫•y d·ªØ li·ªáu t∆∞∆°ng t·ª±:</strong><br>`;
            message += similarUsernames.map(user => `‚Ä¢ ${user}`).join('<br>') + '<br><br>';
        }
        
        message += `B·∫°n c√≥ th·ªÉ:<br>
                   üì§ T·∫£i l√™n d·ªØ li·ªáu m·ªõi b·∫±ng n√∫t "T·∫£i l√™n d·ªØ li·ªáu"<br>
                   üîÑ L√†m m·ªõi danh s√°ch<br>
                   üéØ T·∫°o d·ªØ li·ªáu m·∫´u ƒë·ªÉ demo<br>
                   üí¨ Ho·∫∑c chat b√¨nh th∆∞·ªùng m√† kh√¥ng c·∫ßn d·ªØ li·ªáu`;
        
        addMessage(message, 'bot');
        
        // Add TTS demo message
        setTimeout(() => {
            addMessage(`üîä <strong>Ch·ª©c nƒÉng Text-to-Speech ƒë√£ s·∫µn s√†ng!</strong><br><br>
                       üé§ S·ª≠ d·ª•ng FPT.AI ƒë·ªÉ chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh gi·ªçng n√≥i<br>
                       üîä Nh·∫•p v√†o bi·ªÉu t∆∞·ª£ng loa üîä b√™n c·∫°nh b·∫•t k·ª≥ tin nh·∫Øn n√†o ƒë·ªÉ nghe<br>
                       ‚å®Ô∏è Ph√≠m t·∫Øt: <kbd>Ctrl+Shift+S</kbd> ƒë·ªÉ ƒë·ªçc tin nh·∫Øn cu·ªëi, <kbd>Esc</kbd> ƒë·ªÉ d·ª´ng<br>
                       üéØ H·ªó tr·ª£ ti·∫øng Vi·ªát v·ªõi ch·∫•t l∆∞·ª£ng cao<br><br>
                       <button onclick="testTextToSpeech()" style="background: #10a37f; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer;">
                           <i class="fas fa-volume-up"></i> Test TTS
                       </button>`, 'bot');
        }, 1000);
    }
}

// Function to check chunking status for documents
async function checkChunkingStatus(username) {
    try {
        const response = await fetch(`/chunking/documents/?uploader_username=${encodeURIComponent(username)}`);
        if (response.ok) {
            const result = await response.json();
            return result.chunked_files || {};
        }
    } catch (error) {
        console.error('Error checking chunking status:', error);
    }
    return {};
}

function displayUserDatabase(data) {
    const userDatabaseList = document.getElementById('userDatabaseList');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const currentUsername = getCurrentUsername();
    
    console.log('üìä Displaying user database data:', data);
    
    // Clear loading indicator
    loadingIndicator.style.display = 'none';
    
    if (!data || data.length === 0) {
        console.log('‚ö†Ô∏è No data to display for user:', currentUsername);
        userDatabaseList.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-database"></i>
                <div>Ch∆∞a c√≥ d·ªØ li·ªáu cho <strong>${currentUsername}</strong></div>
                <small>Vui l√≤ng t·∫£i l√™n t√†i li·ªáu ƒë·ªÉ b·∫Øt ƒë·∫ßu</small>
            </div>
        `;
        return;
    }
    
    console.log('‚úÖ Rendering', data.length, 'entries');
    
    // First, render documents with loading status
    userDatabaseList.innerHTML = data.map(entry => {
        const displayName = entry.file_data?.filename || entry.metadata?.description || entry.source_file || 'T√†i li·ªáu kh√¥ng c√≥ t√™n';
        const sourceFile = entry.source_file || 'unknown';
        
        return `
            <div class="user-db-entry loading" onclick="selectUserData('${entry.uploader_username}', '${sourceFile}')">
                <div class="user-db-username">
                    <i class="fas fa-user"></i> ${entry.uploader_username}
                </div>
                <div class="user-db-info">
                    <i class="fas fa-file"></i> ${displayName}
                </div>
                <div class="user-db-actions">
                    <button class="btn-read-doc" onclick="event.stopPropagation(); readDocument('${entry.uploader_username}', '${sourceFile}')">
                        <i class="fas fa-book-open"></i> ƒê·ªçc 
                    </button>
                    <button class="btn-delete-doc" onclick="event.stopPropagation(); showDeleteOptions('${entry.uploader_username}', '${sourceFile}')">
                        <i class="fas fa-trash"></i> Xo√°
                    </button>
                    <button class="upload-date" style="display: flex; padding: 10px; align-items: center; gap: 4px;"
                        onmouseenter="this.setAttribute('title', 'Ng√†y t·∫£i l√™n: ${entry.upload_date ? formatDate(entry.upload_date) : 'Kh√¥ng r√µ'}')"
                        onmouseleave="this.removeAttribute('title')">
                        <i class="fas fa-calendar" style="color: #10a37f;"></i>
                        <span class="upload-date-text">Th·ªùi gian</span>
                    </button>
                </div>
                <div class="chunking-status loading">
                    <i class="fas fa-spinner fa-spin"></i> ƒêang ki·ªÉm tra...
                </div>
            </div>
        `;
    }).join('');
    
    // Then, check chunking status for each user and update display
    updateChunkingStatusDisplay(data);
}

// Th√™m h√†m m·ªõi n√†y v√†o trong th·∫ª <script>
async function toggleFilePin(docId) {
    try {
        // Gi·∫£ ƒë·ªãnh API endpoint c·ªßa b·∫°n. B·∫°n c·∫ßn t·∫°o API n√†y ·ªü backend.
        const response = await fetch(`/api/documents/${docId}/toggle_pin/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
            }
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Thao t√°c ghim/b·ªè ghim th·∫•t b·∫°i');
        }

        const result = await response.json();

        // C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c m√† kh√¥ng c·∫ßn t·∫£i l·∫°i trang
        const entryDiv = document.getElementById(`doc-entry-${docId}`);
        const pinBtn = entryDiv.querySelector('.btn-pin-file');

        if (result.is_pinned) {
            entryDiv.classList.add('pinned');
            pinBtn.classList.add('active');
            showSuccessNotification('ƒê√£ ghim t√†i li·ªáu!');
        } else {
            entryDiv.classList.remove('pinned');
            pinBtn.classList.remove('active');
            showInfoNotification('ƒê√£ b·ªè ghim t√†i li·ªáu.');
        }

        // T√πy ch·ªçn: ƒê·ªÉ s·∫Øp x·∫øp l·∫°i danh s√°ch, b·∫°n c√≥ th·ªÉ g·ªçi l·∫°i loadUserDatabase()
        // Tuy nhi√™n, vi·ªác n√†y s·∫Ω l√†m trang t·∫£i l·∫°i, c·∫≠p nh·∫≠t t·ª©c th√¨ s·∫Ω m∆∞·ª£t h∆°n.
        // N·∫øu mu·ªën s·∫Øp x·∫øp l·∫°i, h√£y b·ªè comment d√≤ng d∆∞·ªõi ƒë√¢y:
        // await loadUserDatabase();

    } catch (error) {
        showErrorNotification('L·ªói khi ghim file', error.message);
    }
}

async function updateChunkingStatusDisplay(data) {
    const usernames = [...new Set(data.map(entry => entry.uploader_username))];
    
    for (const username of usernames) {
        try {
            const chunkingStatus = await checkChunkingStatus(username);
            console.log(`üîç Chunking status for ${username}:`, chunkingStatus);
            
            // Update each document entry for this user
            data.filter(entry => entry.uploader_username === username).forEach(entry => {
                const sourceFile = entry.source_file || 'unknown';
                const isChunked = chunkingStatus[sourceFile] && chunkingStatus[sourceFile] > 0;
                const chunkCount = chunkingStatus[sourceFile] || 0;
                
                // Find the DOM element and update it
                const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
                if (entryElement) {
                    // Remove loading class and add appropriate status class
                    entryElement.classList.remove('loading');
                    entryElement.classList.add(isChunked ? 'chunked' : 'not-chunked');
                    
                    // Update status badge
                    const statusBadge = entryElement.querySelector('.chunking-status');
                    if (statusBadge) {
                        statusBadge.classList.remove('loading');
                        statusBadge.classList.add(isChunked ? 'chunked' : 'not-chunked');
                        
                        if (isChunked) {
                            statusBadge.innerHTML = `<i class="fas fa-check-circle"></i> ƒê√£ ƒë·ªçc (${chunkCount})`;
                        } else {
                            statusBadge.innerHTML = `<i class="fas fa-clock"></i> Ch∆∞a ƒë·ªçc`;
                        }
                    }
                }
            });
            
        } catch (error) {
            console.error(`Error checking chunking status for ${username}:`, error);
            
            // Update to show error state
            data.filter(entry => entry.uploader_username === username).forEach(entry => {
                const sourceFile = entry.source_file || 'unknown';
                const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
                if (entryElement) {
                    entryElement.classList.remove('loading');
                    entryElement.classList.add('not-chunked');
                    
                    const statusBadge = entryElement.querySelector('.chunking-status');
                    if (statusBadge) {
                        statusBadge.classList.remove('loading');
                        statusBadge.classList.add('not-chunked');
                        statusBadge.innerHTML = `<i class="fas fa-question-circle"></i> Kh√¥ng r√µ`;
                    }
                }
            });
        }
    }
}

function selectUserData(username, sourceFile) {
    // Remove previous selection
    document.querySelectorAll('.user-db-entry').forEach(el => {
        el.classList.remove('selected');
    });
    
    // Add selection to clicked item
    event.currentTarget.classList.add('selected');
    
    selectedUserData = userDatabaseCache.find(entry => 
        entry.uploader_username === username && 
        (entry.source_file === sourceFile || entry.file_data?.filename === sourceFile)
    );
    
    if (selectedUserData) {
        showSuccessNotification(
            `<strong>ƒê√£ ch·ªçn t√†i li·ªáu:</strong><br>
             üë§ Ng∆∞·ªùi d√πng: ${selectedUserData.uploader_username}<br>
             üìÅ File: ${selectedUserData.source_file || selectedUserData.file_data?.filename || 'Kh√¥ng c√≥ t√™n'}<br>
             üìÖ Ng√†y t·∫£i: ${formatDate(selectedUserData.upload_date)}<br>`,
            ''
        );
    }
}

// Helper function to update single document chunking status
async function updateSingleDocumentStatus(username, sourceFile) {
    try {
        const response = await fetch(`/chunking/documents/?uploader_username=${encodeURIComponent(username)}&source_file=${encodeURIComponent(sourceFile)}`);
        if (response.ok) {
            const result = await response.json();
            const isChunked = result.chunked || false;
            const chunkCount = result.chunk_count || 0;
            
            // Find the DOM element and update it
            const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
            if (entryElement) {
                // Remove old status classes
                entryElement.classList.remove('chunked', 'not-chunked', 'loading');
                entryElement.classList.add(isChunked ? 'chunked' : 'not-chunked');
                
                // Update status badge
                const statusBadge = entryElement.querySelector('.chunking-status');
                if (statusBadge) {
                    statusBadge.classList.remove('chunked', 'not-chunked', 'loading');
                    statusBadge.classList.add(isChunked ? 'chunked' : 'not-chunked');
                    
                    if (isChunked) {
                        statusBadge.innerHTML = `<i class="fas fa-check-circle"></i> ƒê√£ chunked (${chunkCount})`;
                    } else {
                        statusBadge.innerHTML = `<i class="fas fa-clock"></i> Ch∆∞a chunked`;
                    }
                }
            }
        }
    } catch (error) {
        console.error('Error updating document status:', error);
    }
}

// New function to read/chunk document
async function readDocument(username, sourceFile) {
    try {
        // Update UI to show processing
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('chunked', 'not-chunked');
                statusBadge.classList.add('loading');
                statusBadge.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ƒêang ƒë·ªçc ...`;
            }
        }
        
        const response = await fetch('/chunking/documents/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                uploader_username: username,
                source_file: sourceFile
            })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showSuccessNotification(`‚úÖ <strong>ƒê·ªçc t√†i li·ªáu th√†nh c√¥ng!</strong><br>
                       üìÑ T√†i li·ªáu: ${sourceFile}<br>
                       üìù ${result.message}<br>
                       üí° B√¢y gi·ªù b·∫°n c√≥ th·ªÉ chat v·ªÅ n·ªôi dung t√†i li·ªáu n√†y!`);
            
            // Update chunking status
            await updateSingleDocumentStatus(username, sourceFile);
            
        } else {
            // Display detailed error information
            let errorMessage = `‚ùå <strong>L·ªói ƒë·ªçc t√†i li·ªáu:</strong><br>
                               üìÑ T√†i li·ªáu: ${sourceFile}<br>
                               üí• ${result.message || 'Kh√¥ng th·ªÉ x·ª≠ l√Ω t√†i li·ªáu'}<br>`;
            
            // Add debug info if available
            if (result.debug_info) {
                errorMessage += `<br>üîç <strong>Debug Info:</strong><br>
                                <pre style="background: #f5f5f5; padding: 10px; font-size: 0.8rem; white-space: pre-wrap;">${result.debug_info}</pre>`;
            }
            
            // Add search strategies tried
            if (result.search_strategies_tried) {
                errorMessage += `<br>üîé <strong>Strategies tried:</strong><br>
                                ${result.search_strategies_tried.map(s => `‚Ä¢ ${s}`).join('<br>')}`;
            }
            
            showErrorNotification(errorMessage);
            
            // Reset status to not-chunked
            if (entryElement) {
                const statusBadge = entryElement.querySelector('.chunking-status');
                if (statusBadge) {
                    statusBadge.classList.remove('loading');
                    statusBadge.classList.add('not-chunked');
                    statusBadge.innerHTML = `<i class="fas fa-clock"></i> Ch∆∞a chunked`;
                }
            }
        }
    } catch (error) {
        console.error('Error reading document:', error);
        showErrorNotification(`‚ùå <strong>L·ªói k·∫øt n·ªëi:</strong><br>
                   Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn service ƒë·ªçc t√†i li·ªáu.<br>
                   üìÑ T√†i li·ªáu: ${sourceFile}<br>
                   üîç Chi ti·∫øt l·ªói: ${error.message}`);
        
        // Reset status to not-chunked
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('loading');
                statusBadge.classList.add('not-chunked');
                statusBadge.innerHTML = `<i class="fas fa-clock"></i> Ch∆∞a chunked`;
            }
        }
    }
}

// New function to delete document chunking data ONLY
async function deleteDocumentChunking(username, sourceFile) {
    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën xo√° CHUNKING data c·ªßa t√†i li·ªáu "${sourceFile}"?\n\n‚ö†Ô∏è L∆∞u √Ω: Ch·ªâ xo√° chunks, document g·ªëc s·∫Ω ƒë∆∞·ª£c gi·ªØ l·∫°i ƒë·ªÉ c√≥ th·ªÉ chunking l·∫°i sau.`)) {
        return;
    }
    
    try {
        // Update UI to show processing
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('chunked', 'not-chunked');
                statusBadge.classList.add('loading');
                statusBadge.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ƒêang xo√° chunks...`;
            }
        }
        
        addMessage(`üóëÔ∏è <strong>ƒêang xo√° chunking data:</strong><br>
                   üë§ Ng∆∞·ªùi d√πng: ${username}<br>
                   üìÅ File: ${sourceFile}<br>
                   ‚è≥ Ch·ªâ xo√° chunks, gi·ªØ l·∫°i document g·ªëc...`, 'bot');
        
        // Delete document chunking ONLY
        const chunkingResponse = await fetch(`/chunking/documents/?uploader_username=${encodeURIComponent(username)}&source_file=${encodeURIComponent(sourceFile)}`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const chunkingResult = await chunkingResponse.json();
        
        // Check results and display detailed info
        const chunkingSuccess = chunkingResponse.ok;
        
        if (chunkingSuccess) {
            let message = `‚úÖ <strong>Xo√° chunking data th√†nh c√¥ng!</strong><br>
                          üìÑ T√†i li·ªáu: ${sourceFile}<br>`;
            
            // Display chunking deletion details
            if (chunkingResult.details) {
                message += `<br>üóëÔ∏è <strong>Chi ti·∫øt xo√° chunking:</strong><br>`;
                if (chunkingResult.details.chunks_deleted > 0) {
                    message += `‚Ä¢ Chunks ƒë√£ xo√°: ${chunkingResult.details.chunks_deleted}<br>`;
                }
                if (chunkingResult.details.document_preserved) {
                    message += `‚Ä¢ Document g·ªëc: ƒê∆∞·ª£c gi·ªØ l·∫°i trong database<br>`;
                }
                if (chunkingResult.details.actual_source_file) {
                    message += `‚Ä¢ Source file ID: ${chunkingResult.details.actual_source_file}<br>`;
                }
            } else {
                message += `üóëÔ∏è ƒê√£ xo√° chunking data: ${chunkingResult.message || 'Ho√†n t·∫•t'}<br>`;
            }
            
            message += `<br>üí° <strong>L∆∞u √Ω:</strong> Document g·ªëc v·∫´n c√≤n, b·∫°n c√≥ th·ªÉ chunking l·∫°i b·∫•t c·ª© l√∫c n√†o!`;
            showSuccessNotification(message);
            
            // Update status to not-chunked (since chunks were deleted but document still exists)
            await updateSingleDocumentStatus(username, sourceFile);
            
        } else {
            let message = `‚ùå <strong>L·ªói xo√° chunking data:</strong><br>
                        üìÑ T√†i li·ªáu: ${sourceFile}<br>
                        üí• ${chunkingResult.message || 'L·ªói kh√¥ng r√µ'}`;
            showErrorNotification(message);
            
            // Reset status since deletion failed
            await updateSingleDocumentStatus(username, sourceFile);
        }
        
    } catch (error) {
        console.error('Error deleting chunking data:', error);
        showErrorNotification(`‚ùå <strong>L·ªói k·∫øt n·ªëi:</strong><br>
                   Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn service xo√° chunking.<br>
                   üìÑ T√†i li·ªáu: ${sourceFile}<br>
                   üîç Chi ti·∫øt l·ªói: ${error.message}`, 'bot');
        
        // Reset status
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('loading');
                statusBadge.classList.add('not-chunked');
                statusBadge.innerHTML = `<i class="fas fa-question-circle"></i> Kh√¥ng r√µ`;
            }
        }
    }
}

// Function to show delete options
function showDeleteOptions(username, sourceFile) {
    const options = [
        {
            text: "üóëÔ∏è Ch·ªâ xo√° Chunks (gi·ªØ l·∫°i t√†i li·ªáu g·ªëc)",
            description: "Xo√° d·ªØ li·ªáu chunking, t√†i li·ªáu g·ªëc v·∫´n c√≤n ƒë·ªÉ chunking l·∫°i sau",
            action: () => deleteDocumentChunking(username, sourceFile)
        },
        {
            text: "üíÄ Xo√° ho√†n to√†n t√†i li·ªáu",
            description: "Xo√° c·∫£ t√†i li·ªáu g·ªëc v√† chunking data (kh√¥ng th·ªÉ kh√¥i ph·ª•c)",
            action: () => deleteDocumentCompletely(username, sourceFile)
        }
    ];
    
    let message = `ü§î <strong>Ch·ªçn h√†nh ƒë·ªông xo√° cho t√†i li·ªáu:</strong><br>
                   üìÑ <strong>${sourceFile}</strong><br><br>`;
    
    options.forEach((option, index) => {
        message += `<button onclick="document.getElementById('deleteOption${index}').click()" 
                           style="display: block; width: 100%; margin: 10px 0; padding: 10px; 
                                  background: ${index === 0 ? '#ffc107' : '#dc3545'}; 
                                  color: white; border: none; border-radius: 8px; cursor: pointer;">
                       ${option.text}
                    </button>
                    <small style="color: #666; font-style: italic;">${option.description}</small><br><br>`;
    });
    
    addMessage(message, 'bot');
    
    // Add hidden buttons to handle actions
    options.forEach((option, index) => {
        const hiddenButton = document.createElement('button');
        hiddenButton.id = `deleteOption${index}`;
        hiddenButton.style.display = 'none';
        hiddenButton.onclick = option.action;
        document.body.appendChild(hiddenButton);
        
        // Auto-remove after 30 seconds
        setTimeout(() => {
            if (document.getElementById(`deleteOption${index}`)) {
                document.body.removeChild(hiddenButton);
            }
        }, 30000);
    });
}

// Function to completely delete document and all its data
async function deleteDocumentCompletely(username, sourceFile) {
    if (!confirm(`‚ö†Ô∏è B·∫†N C√ì CH·∫ÆC CH·∫ÆN MU·ªêN XO√Å HO√ÄN TO√ÄN T√ÄI LI·ªÜU "${sourceFile}"?\n\nüíÄ H√†nh ƒë·ªông n√†y s·∫Ω xo√°:\n‚Ä¢ T√†i li·ªáu g·ªëc trong database\n‚Ä¢ T·∫•t c·∫£ chunking data\n\nüö® KH√îNG TH·ªÇ KH√îI PH·ª§C sau khi xo√°!`)) {
        return;
    }
    
    try {
        // Update UI to show processing
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('chunked', 'not-chunked');
                statusBadge.classList.add('loading');
                statusBadge.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ƒêang xo√° ho√†n to√†n...`;
            }
        }
        
        addMessage(`üíÄ <strong>ƒêang xo√° ho√†n to√†n t√†i li·ªáu:</strong><br>
                   üë§ Ng∆∞·ªùi d√πng: ${username}<br>
                   üìÅ File: ${sourceFile}<br>
                   ‚è≥ Xo√° c·∫£ document g·ªëc v√† chunking data...`, 'bot');
        
        // Delete chunking data first
        const chunkingResponse = await fetch(`/chunking/documents/?uploader_username=${encodeURIComponent(username)}&source_file=${encodeURIComponent(sourceFile)}`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const chunkingResult = await chunkingResponse.json();
        
        // Delete user database entry
        const dbResponse = await fetch(`/api/user-database/?uploader_username=${encodeURIComponent(username)}&source_file=${encodeURIComponent(sourceFile)}`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        const dbResult = await dbResponse.json();
        
        // Check results and display detailed info
        const chunkingSuccess = chunkingResponse.ok;
        const dbSuccess = dbResponse.ok && dbResult.success;
        
        if (chunkingSuccess && dbSuccess) {
            let message = `‚úÖ <strong>Xo√° ho√†n to√†n th√†nh c√¥ng!</strong><br>
                          üìÑ T√†i li·ªáu: ${sourceFile}<br>`;
            
            // Display chunking deletion details
            if (chunkingResult.details) {
                message += `<br>üóëÔ∏è <strong>Chi ti·∫øt xo√° chunking:</strong><br>`;
                if (chunkingResult.details.chunks_deleted > 0) {
                    message += `‚Ä¢ Chunks ƒë√£ xo√°: ${chunkingResult.details.chunks_deleted}<br>`;
                }
            }
            
            // Display database deletion details
            if (dbResult.details) {
                message += `<br>üóÉÔ∏è <strong>Chi ti·∫øt xo√° database:</strong><br>`;
                if (dbResult.details.strategy_used) {
                    message += `‚Ä¢ Ph∆∞∆°ng ph√°p: ${dbResult.details.strategy_used}<br>`;
                }
                if (dbResult.details.filename) {
                    message += `‚Ä¢ T√™n file: ${dbResult.details.filename}<br>`;
                }
            }
            
            message += `<br>üíÄ <strong>T√†i li·ªáu ƒë√£ b·ªã xo√° ho√†n to√†n kh·ªèi h·ªá th·ªëng!</strong>`;
            showSuccessNotification(message);
            
            // Remove the document from display
            if (entryElement) {
                entryElement.remove();
            }
            
        } else if (chunkingSuccess && !dbSuccess) {
            let message = `‚ö†Ô∏è <strong>Xo√° m·ªôt ph·∫ßn th√†nh c√¥ng:</strong><br>
                          üìÑ T√†i li·ªáu: ${sourceFile}<br>
                          ‚úÖ ƒê√£ xo√° chunking data<br>
                          ‚ùå L·ªói xo√° database entry: ${dbResult.message || 'Kh√¥ng r√µ'}`;
            
            showInfoNotification(message);
            await updateSingleDocumentStatus(username, sourceFile);
            
        } else if (!chunkingSuccess && dbSuccess) {
            let message = `‚ö†Ô∏è <strong>Xo√° m·ªôt ph·∫ßn th√†nh c√¥ng:</strong><br>
                          üìÑ T√†i li·ªáu: ${sourceFile}<br>
                          ‚úÖ ƒê√£ xo√° database entry<br>
                          ‚ùå L·ªói xo√° chunking data: ${chunkingResult.message || 'Kh√¥ng r√µ'}`;
            
            showInfoNotification(message);
            await updateSingleDocumentStatus(username, sourceFile);
            
        } else {
            let message = `‚ùå <strong>L·ªói xo√° t√†i li·ªáu:</strong><br>
                          üìÑ T√†i li·ªáu: ${sourceFile}<br>
                          üí• Chunking: ${chunkingResult.message || 'L·ªói kh√¥ng r√µ'}<br>
                          üí• Database: ${dbResult.message || 'L·ªói kh√¥ng r√µ'}`;
            
            showErrorNotification(message);
            await updateSingleDocumentStatus(username, sourceFile);
        }
        
        // Refresh the document list
        loadUserDatabase();
        
    } catch (error) {
        console.error('Error completely deleting document:', error);
        showErrorNotification(`‚ùå <strong>L·ªói k·∫øt n·ªëi:</strong><br>
                   Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server ƒë·ªÉ xo√° t√†i li·ªáu.<br>
                   üìÑ T√†i li·ªáu: ${sourceFile}<br>
                   üîç Chi ti·∫øt l·ªói: ${error.message}`, 'bot');
        
        // Reset status
        const entryElement = document.querySelector(`[onclick="selectUserData('${username}', '${sourceFile}')"]`);
        if (entryElement) {
            const statusBadge = entryElement.querySelector('.chunking-status');
            if (statusBadge) {
                statusBadge.classList.remove('loading');
                statusBadge.classList.add('not-chunked');
                statusBadge.innerHTML = `<i class="fas fa-question-circle"></i> Kh√¥ng r√µ`;
            }
        }
    }
}
 
 // Remove upload modal and related functions
 function uploadUserData() {
     showWarningNotification('Ch·ª©c nƒÉng t·∫£i l√™n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a', 'Vui l√≤ng s·ª≠ d·ª•ng c√°c trang ch·ª©c nƒÉng kh√°c ƒë·ªÉ t·∫£i l√™n t√†i li·ªáu.');
 }
 
 // Search for user data by username
 async function searchUserDataByUsername(username) {
     try {
         const response = await fetch(`/api/user-database/?uploader_username=${encodeURIComponent(username)}`);
         const result = await response.json();
         
         if (result.success && result.data) {
             return result.data;
         } else {
             console.log(`No data found for username: ${username}`);
             return null;
         }
     } catch (error) {
         console.error('Error searching user data:', error);
         return null;
     }
 }
 
 // Load user's own data specifically
 async function loadMyUserData() {
     const currentUsername = getCurrentUsername();
     
     if (!currentUsername || currentUsername === 'unknown_user') {
         showError('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh t√™n ng∆∞·ªùi d√πng hi·ªán t·∫°i');
         return;
     }
     
     try {
         const userData = await searchUserDataByUsername(currentUsername);
         
         if (userData) {
             selectedUserData = userData;
             
             addMessage(`üéØ <strong>T√¨m th·∫•y t√†i li·ªáu c·ªßa b·∫°n:</strong><br>
                        üë§ Ng∆∞·ªùi d√πng: ${userData.uploader_username}<br>
                        üìÅ File: ${userData.source_file || userData.file_data?.filename || 'Kh√¥ng c√≥ t√™n'}<br>
                        üìÖ Ng√†y t·∫£i: ${formatDate(userData.upload_date)}<br>
                        üìù M√¥ t·∫£: ${userData.metadata?.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}<br><br>
                        ‚ú® S·∫µn s√†ng ƒë·ªÉ ph√¢n t√≠ch v√† tr√≤ chuy·ªán!`, 'bot');
         } else {
             addMessage(`üîç <strong>Kh√¥ng t√¨m th·∫•y t√†i li·ªáu:</strong><br><br>
                        Ch∆∞a c√≥ t√†i li·ªáu n√†o cho t√†i kho·∫£n <strong>${currentUsername}</strong>.<br>
                        B·∫°n c√≥ th·ªÉ:<br>
                        üì§ T·∫£i l√™n t√†i li·ªáu m·ªõi<br>
                        üîÑ L√†m m·ªõi danh s√°ch<br>
                        üí¨ V·∫´n c√≥ th·ªÉ chat b√¨nh th∆∞·ªùng`, 'bot');
         }
     } catch (error) {
         showError('L·ªói khi t√¨m ki·∫øm t√†i li·ªáu ng∆∞·ªùi d√πng');
     }
 }
 
 // Utility functions
 function formatDate(dateString) {
     const date = new Date(dateString);
     return date.toLocaleDateString('vi-VN', {
         year: 'numeric',
         month: 'short',
         day: 'numeric',
         hour: '2-digit',
         minute: '2-digit'
     });
 }
 
 function getCookie(name) {
     let cookieValue = null;
     if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
             const cookie = cookies[i].trim();
             if (cookie.substring(0, name.length + 1) === (name + '=')) {
                 cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                 break;
             }
         }
     }
     return cookieValue;
 }
 
 function showError(message) {
     showErrorNotification('L·ªói', message);
 }
 
 // Original chat functions
 function handleKeyPress(event) {
     if (event.key === 'Enter') {
         event.preventDefault();
         sendMessage();
     }
 }
 
 function sendMessage() {
     const input = document.getElementById('messageInput');
     const message = input.value.trim();
     
     if (!message) return;
     
     // Add user message first
     addMessage(message, 'user');
     input.value = '';
     
     // Show thinking indicator immediately with animation
     showThinkingIndicator();
     
     // Scroll to bottom to show the thinking indicator
     document.getElementById('chatBody').scrollTop = document.getElementById('chatBody').scrollHeight;
     
     // Send message to WoxionChat service
     sendToWoxionChat(message);
 }

 // New function to show the enhanced thinking indicator
 function showThinkingIndicator() {
     const indicator = document.getElementById('typingIndicator');
     indicator.classList.remove('show'); // Reset animation
     indicator.style.display = 'block';
     
     // Trigger animation with slight delay for smooth effect
     setTimeout(() => {
         indicator.classList.add('show');
     }, 10);
     
     console.log('üß† Thinking indicator shown');
 }

 // New function to hide the thinking indicator
 function hideThinkingIndicator() {
     const indicator = document.getElementById('typingIndicator');
     indicator.classList.remove('show');
     
     // Hide after animation completes
     setTimeout(() => {
         indicator.style.display = 'none';
     }, 300);
     
     console.log('üß† Thinking indicator hidden');
 }
 
 async function sendToWoxionChat(message) {
     try {
         // Prevent multiple simultaneous requests
         if (ongoingChatRequest) {
             console.log('‚ö†Ô∏è Chat request already in progress, ignoring new request');
             addBotMessageWithTypewriter('‚è≥ <strong>Vui l√≤ng ch·ªù:</strong><br>ƒêang x·ª≠ l√Ω y√™u c·∫ßu tr∆∞·ªõc ƒë√≥...');
             return;
         }
         
         const currentUsername = getCurrentUsername();
         
         // Mark request as ongoing
         ongoingChatRequest = true;
         
         // Start heartbeat to prevent timeouts
         startHeartbeat();
         
         // Prepare the request payload for WoxionChat
         const payload = {
             message: message,  // WoxionChat expects 'query' not 'message'
             user_id: currentUsername,
             session_id: `session_${currentUsername}_${Date.now()}`,
             // Include selected document info if available
             context: selectedUserData ? {
                 selected_document: {
                     username: selectedUserData.uploader_username,
                     source_file: selectedUserData.source_file,
                     filename: selectedUserData.file_data?.filename,
                     description: selectedUserData.metadata?.description
                 }
             } : {},
             // Additional WoxionChat parameters
             memory_enabled: true,
             use_documents: selectedUserData ? true : false,
             // System prompt ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªãnh d·∫°ng Markdown
             system_prompt: `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n gia, c√≥ nhi·ªám v·ª• ph√¢n t√≠ch th√¥ng tin ƒë∆∞·ª£c cung c·∫•p v√† tr√¨nh b√†y c√¢u tr·∫£ l·ªùi cho ng∆∞·ªùi d√πng m·ªôt c√°ch r√µ r√†ng, logic v√† c√≥ c·∫•u tr√∫c cao.

QUY T·∫ÆC B·∫ÆT BU·ªòC: TO√ÄN B·ªò PH·∫¢N H·ªíI C·ª¶A B·∫†N PH·∫¢I ·ªû ƒê·ªäNH D·∫†NG MARKDOWN. KH√îNG BAO GI·ªú VI·∫æT HTML.

H√£y tu√¢n th·ªß nghi√™m ng·∫∑t c√°c quy t·∫Øc ƒë·ªãnh d·∫°ng sau ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n v√† d·ªÖ ƒë·ªçc:

1. **Ti√™u ƒë·ªÅ (Headings):** S·ª≠ d·ª•ng \`##\` cho c√°c ph·∫ßn ch√≠nh v√† \`###\` cho c√°c ti·ªÉu m·ª•c ƒë·ªÉ t·∫°o ra h·ªá th·ªëng ph√¢n c·∫•p r√µ r√†ng. B·∫Øt ƒë·∫ßu b·∫±ng m·ªôt ti√™u ƒë·ªÅ ch√≠nh t√≥m t·∫Øt n·ªôi dung.

2. **Danh s√°ch (Lists):**
   * S·ª≠ d·ª•ng d·∫•u \`*\` ho·∫∑c \`-\` cho c√°c danh s√°ch kh√¥ng c√≥ th·ª© t·ª±.
   * S·ª≠ d·ª•ng s·ªë (\`1.\`, \`2.\`) cho c√°c h∆∞·ªõng d·∫´n t·ª´ng b∆∞·ªõc ho·∫∑c khi th·ª© t·ª± quan tr·ªçng.
   * S·ª≠ d·ª•ng th·ª•t l·ªÅ ƒë·ªÉ t·∫°o danh s√°ch con (nested lists).

3. **Nh·∫•n m·∫°nh (Emphasis):**
   * S·ª≠ d·ª•ng \`**vƒÉn b·∫£n in ƒë·∫≠m**\` cho c√°c thu·∫≠t ng·ªØ quan tr·ªçng ho·∫∑c c√°c k·∫øt lu·∫≠n ch√≠nh.
   * S·ª≠ d·ª•ng \`*vƒÉn b·∫£n in nghi√™ng*\` ƒë·ªÉ nh·∫•n m·∫°nh nh·∫π nh√†ng h∆°n.

4. **M√£ n·ªôi tuy·∫øn (Inline Code):** S·ª≠ d·ª•ng d·∫•u backtick ( \` ) ƒë·ªÉ bao b·ªçc c√°c thu·∫≠t ng·ªØ k·ªπ thu·∫≠t, t√™n file, t·ª´ vi·∫øt t·∫Øt, ho·∫∑c c√°c ƒëo·∫°n m√£ ng·∫Øn.

5. **Kh·ªëi m√£ (Code Blocks):** ƒê·ªëi v·ªõi c√°c ƒëo·∫°n m√£ nhi·ªÅu d√≤ng, h√£y s·ª≠ d·ª•ng ba d·∫•u backtick ( \`\`\` ) v√† ch·ªâ ƒë·ªãnh ng√¥n ng·ªØ l·∫≠p tr√¨nh n·∫øu c√≥ th·ªÉ.

6. **B·∫£ng (Tables):** Khi c·∫ßn so s√°nh, h√£y tr√¨nh b√†y th√¥ng tin d∆∞·ªõi d·∫°ng b·∫£ng Markdown.

7. **Tr√≠ch d·∫´n (Blockquotes):** S·ª≠ d·ª•ng d·∫•u \`>\` ƒë·ªÉ l√†m n·ªïi b·∫≠t c√°c c·∫£nh b√°o, ghi ch√∫ quan tr·ªçng ho·∫∑c c√°c tr√≠ch d·∫´n tr·ª±c ti·∫øp.

8. **Thanh ph√¢n c√°ch (Horizontal Rules):** S·ª≠ d·ª•ng \`---\` ƒë·ªÉ t√°ch bi·ªát c√°c ph·∫ßn n·ªôi dung ho√†n to√†n kh√°c nhau.

K·∫øt qu·∫£ s·∫Ω l√† ƒëo·∫°n Markdown c√≥ c·∫•u tr√∫c ho√†n h·∫£o, s·∫µn s√†ng ƒë·ªÉ render b·∫±ng marked.js.`
         };
         
         // Debug logging
         console.log('üîç Sending to WoxionChat (NO TIMEOUT):', {
             endpoint: '/chat/chat',
             payload: payload,
             selectedDocument: selectedUserData ? selectedUserData.source_file : 'none',
             timestamp: new Date().toISOString()
         });
         
         // Show typing indicator (already shown in sendMessage, but ensure it's visible)
         // Note: indicator already shown from sendMessage function
         
         // Create AbortController without timeout to prevent any automatic cancellation
         const controller = new AbortController();
         
         // Send request to WoxionChat via proxy (absolutely no timeout limits)
         const response = await fetch('/chat/chat', {
             method: 'POST',
             headers: {
                 'Content-Type': 'application/json',
                 'X-CSRFToken': getCookie('csrftoken'),
                 'Connection': 'keep-alive',
                 'Cache-Control': 'no-cache',
                 'Keep-Alive': 'timeout=0, max=1000'  // Disable keep-alive timeout
             },
             body: JSON.stringify(payload),
             // Multiple strategies to prevent timeout
             signal: controller.signal,  // AbortController without timeout
             keepalive: true,           // Keep connection alive
             cache: 'no-cache'         // Prevent caching issues
             // Note: No timeout parameter = unlimited timeout
         });
         
         // Hide typing indicator when response is received
         hideThinkingIndicator();
         
         console.log('üì° WoxionChat response received at:', new Date().toISOString(), 'Status:', response.status);
         
         if (response.ok) {
             const result = await response.json();
             console.log('‚úÖ WoxionChat response:', result);
             
             // Display WoxionChat response
             if (result.response) {
                 addBotMessageWithTypewriter(`${result.response}`);
             } else if (result.message) {
                 addBotMessageWithTypewriter(`${result.message}`);
             } else if (result.answer) {
                 addBotMessageWithTypewriter(`${result.answer}`);
             } else {
                 addBotMessageWithTypewriter('‚úÖ ƒê√£ nh·∫≠n ph·∫£n h·ªìi t·ª´ WoxionChat<br>' + JSON.stringify(result));
             }
             
             // Show additional info if available
             if (result.sources && result.sources.length > 0) {
                 let contextInfo = '<br><br>üìö <strong>Ngu·ªìn tham kh·∫£o:</strong><br>';
                 contextInfo += result.sources.map((source, index) => `${index + 1}. ${source}`).join('<br>');
                 addBotMessageWithTypewriter(contextInfo);
             }
             
             if (result.context && result.context !== '{}') {
                 addBotMessageWithTypewriter(`<br>üîç <strong>Context:</strong> ${result.context}`);
             }
             
         } else {
             // Handle error responses
             const errorText = await response.text();
             let errorData = null;
             
             try {
                 errorData = JSON.parse(errorText);
             } catch (e) {
                 console.error('Failed to parse error response as JSON:', errorText);
             }
             
             console.error('‚ùå WoxionChat error:', {
                 status: response.status,
                 statusText: response.statusText,
                 errorData: errorData,
                 rawText: errorText
             });
             
             let errorMessage = '‚ùå <strong>L·ªói t·ª´ WoxionChat:</strong><br>';
             
             if (errorData && errorData.error) {
                 errorMessage += errorData.error;
                 if (errorData.message) {
                     errorMessage += `<br>Chi ti·∫øt: ${errorData.message}`;
                 }
             } else if (errorData && errorData.message) {
                 errorMessage += errorData.message;
             } else {
                 errorMessage += `HTTP ${response.status}: ${response.statusText}`;
                 if (errorText && errorText.length < 200) {
                     errorMessage += `<br>Response: ${errorText}`;
                 }
             }
             
             addMessage(errorMessage, 'bot');
             
             // Simple fallback message instead of generateAdvancedResponse
             addBotMessageWithTypewriter(`<br>üîÑ <strong>Ph·∫£n h·ªìi d·ª± ph√≤ng:</strong><br>Xin l·ªói, WoxionChat hi·ªán kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau.`);
             addMessage(`<br>üîÑ <strong>Ph·∫£n h·ªìi d·ª± ph√≤ng:</strong><br>Xin l·ªói, WoxionChat hi·ªán kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau.`, 'bot');
         }
         
     } catch (error) {
         // Hide typing indicator on error
         hideThinkingIndicator();
         
         console.error('‚ùå Error sending to WoxionChat:', error);
         
         // Show connection error
         addMessage(`‚ùå <strong>L·ªói k·∫øt n·ªëi WoxionChat:</strong><br>
                    ${error.message}<br><br>
                    üîÑ ƒêang chuy·ªÉn sang ch·∫ø ƒë·ªô d·ª± ph√≤ng...`, 'bot');
         
         // Simple fallback message immediately without delay
         addMessage(`<strong>Ch·∫ø ƒë·ªô d·ª± ph√≤ng:</strong><br>Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn WoxionChat. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi v√† th·ª≠ l·∫°i.`, 'bot');
     } finally {
         // Always cleanup after request completes (success or failure)
         ongoingChatRequest = null;
         stopHeartbeat();
         
         // Ensure thinking indicator is hidden
         hideThinkingIndicator();
         
         console.log('üèÅ Chat request completed at:', new Date().toISOString());
     }
 }
 
 function addMessage(content, type) {
     const chatBody = document.getElementById('chatBody');
     const messageDiv = document.createElement('div');
     messageDiv.className = `message ${type}`;
     
     const now = new Date();
     const timeString = now.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
     
     // Generate unique ID for this message
     const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
     messageDiv.id = messageId;
     
     // Process content based on type
     let processedContent = content;
     let cleanText = content;
     
     if (type === 'bot') {
         // For bot messages, check if content looks like Markdown
         if (isMarkdownContent(content)) {
             try {
                 // Configure marked.js for safe rendering
                 marked.setOptions({
                     breaks: true,
                     gfm: true,
                     sanitize: false,
                     smartLists: true,
                     smartypants: true
                 });
                 
                 // Convert Markdown to HTML
                 processedContent = marked.parse(content);
                 console.log('üìù Converted Markdown to HTML for bot message');
             } catch (error) {
                 console.error('‚ùå Error parsing Markdown:', error);
                 // Fallback to original content if Markdown parsing fails
                 processedContent = content;
             }
         }
         // Extract clean text for TTS (remove HTML tags)
         cleanText = processedContent.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
     } else {
         // For user messages, treat as plain text
         cleanText = content.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
     }
     
     // Create buttons based on message type
     let buttonsHtml = '';
     if (type === 'bot') {
         // For bot messages, show both pin and speaker buttons
         buttonsHtml = `
             <button class="pin-btn" onclick="toggleMessagePin('${messageId}')" title="Ghim tin nh·∫Øn">
                 <i class="fas fa-thumbtack"></i>
             </button>
             <button class="speaker-btn" onclick="speakMessage('${messageId}')" title="ƒê·ªçc tin nh·∫Øn">
                 <i class="fas fa-volume-up"></i>
             </button>
         `;
     } else {
         // For user messages, show only speaker button
         buttonsHtml = `
             <button class="speaker-btn" onclick="speakMessage('${messageId}')" title="ƒê·ªçc tin nh·∫Øn">
                 <i class="fas fa-volume-up"></i>
             </button>
         `;
     }
     
     messageDiv.innerHTML = `
         <div class="message-content">${processedContent}</div>
         <div class="message-footer">
             <div class="message-time" style="align-items: center;">${timeString}</div>
             ${buttonsHtml}
         </div>
     `;
     
     // Store clean text as data attribute for TTS
     messageDiv.setAttribute('data-text', cleanText);
     
     chatBody.appendChild(messageDiv);
     chatBody.scrollTop = chatBody.scrollHeight;
 }
 
 // Helper function to detect if content is Markdown
 function isMarkdownContent(content) {
     // Check for common Markdown patterns
     const markdownPatterns = [
         /^#{1,6}\s+.+/m,           // Headers (# ## ###)
         /\*\*[^*]+\*\*/,           // Bold text
         /\*[^*]+\*/,               // Italic text
         /`[^`]+`/,                 // Inline code
         /^```[\s\S]*?```/m,        // Code blocks
         /^\* |\*\s+/m,             // Unordered lists
         /^\d+\.\s+/m,              // Ordered lists
         /^>\s+/m,                  // Blockquotes
         /^---+$/m,                 // Horizontal rules
         /\[[^\]]+\]\([^)]+\)/      // Links
     ];
     
     return markdownPatterns.some(pattern => pattern.test(content));
 }
 
 // Focus on input when page loads
 document.getElementById('messageInput').focus();
 
 // Debug function to test the system
 async function debugUserDatabase() {
     showInfoNotification('Ch·ª©c nƒÉng Debug ƒë√£ b·ªã v√¥ hi·ªáu h√≥a', 'S·ª≠ d·ª•ng Developer Console ƒë·ªÉ debug n·∫øu c·∫ßn thi·∫øt.');
 }
 
 async function testDirectAPI() {
     showInfoNotification('Ch·ª©c nƒÉng Test API ƒë√£ b·ªã v√¥ hi·ªáu h√≥a', 'S·ª≠ d·ª•ng Developer Console ƒë·ªÉ test API n·∫øu c·∫ßn thi·∫øt.');
 }
 
 // Test WoxionChat connection
 async function testWoxionChat() {
     try {
         showInfoNotification('üîç ƒêang ki·ªÉm tra k·∫øt n·ªëi WoxionChat...', 'Vui l√≤ng ch·ªù m·ªôt ch√∫t');
         
         const response = await fetch('/chat/health', {
             method: 'GET',
             headers: {
                 'X-CSRFToken': getCookie('csrftoken')
             }
         });
         
         if (response.ok) {
             const result = await response.json();
             
             let message = '‚úÖ <strong>WoxionChat ho·∫°t ƒë·ªông t·ªët!</strong><br>';
             message += `üìä Status: ${result.status}<br>`;
             if (result.message) {
                 message += `üí¨ Message: ${result.message}<br>`;
             }
             if (result.redis) {
                 message += `üî¥ Redis: ${result.redis.status}<br>`;
             }
             
             showSuccessNotification(message);
             
             // Add to chat
             addMessage(`üîß <strong>Test WoxionChat th√†nh c√¥ng!</strong><br>${message}`, 'bot');
             
         } else {
             const errorData = await response.json().catch(() => null);
             let errorMessage = `‚ùå WoxionChat kh√¥ng ph·∫£n h·ªìi (${response.status})`;
             if (errorData && errorData.error) {
                 errorMessage += `<br>Chi ti·∫øt: ${errorData.error}`;
             }
             
             showErrorNotification(errorMessage);
             addMessage(errorMessage, 'bot');
         }
         
     } catch (error) {
         const errorMessage = `‚ùå <strong>L·ªói k·∫øt n·ªëi WoxionChat:</strong><br>${error.message}<br><br>üí° ƒê·∫£m b·∫£o service ƒëang ch·∫°y tr√™n port 5002`;
         showErrorNotification(errorMessage);
         addMessage(errorMessage, 'bot');
     }
 }
 
 // Heartbeat function to prevent server-side timeouts
function startHeartbeat() {
    // Clear any existing heartbeat
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
    }
    
    // Send a heartbeat every 30 seconds to keep the connection alive
    heartbeatInterval = setInterval(async () => {
        try {
            // Send a lightweight ping to keep the connection alive
            await fetch('/chat/health', {
                method: 'GET',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Connection': 'keep-alive'
                },
                keepalive: true,
                cache: 'no-cache'
            });
            console.log('üì° Heartbeat sent to maintain connection');
        } catch (error) {
            console.log('‚ö†Ô∏è Heartbeat failed (non-critical):', error.message);
        }
    }, 30000); // Every 30 seconds
}

function stopHeartbeat() {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
        console.log('üíî Heartbeat stopped');
    }
}

// Start the heartbeat when the page loads
document.addEventListener('DOMContentLoaded', startHeartbeat);

// Cleanup when user leaves the page
window.addEventListener('beforeunload', function() {
    stopHeartbeat();
    console.log('üîÑ Page unloading, cleaned up heartbeat');
});

// Also cleanup on page visibility change (e.g., switching tabs)
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden') {
        // Page is hidden, continue heartbeat but reduce frequency
        console.log('üëÅÔ∏è Page hidden, continuing heartbeat...');
    } else {
        // Page is visible again, ensure heartbeat is running
        if (!heartbeatInterval) {
            startHeartbeat();
            console.log('üëÅÔ∏è Page visible again, restarted heartbeat');
        }
    }
});

// Function to test and warn about server timeout settings
async function checkServerTimeoutSettings() {
    try {
        console.log('üîç Checking server timeout settings...');
        
        // Test long request simulation
        const startTime = Date.now();
        const response = await fetch('/chat/health', {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Connection': 'keep-alive',
                'Cache-Control': 'no-cache'
            },
            keepalive: true,
            cache: 'no-cache'
        });
        
        const endTime = Date.now();
        const responseTime = endTime - startTime;
        
        console.log(`‚è±Ô∏è Server response time: ${responseTime}ms`);
        
        if (response.ok) {
            console.log('‚úÖ Server connection is healthy');
            if (responseTime > 5000) {
                console.log('‚ö†Ô∏è Warning: Server is responding slowly, might indicate timeout issues');
            }
        } else {
            console.log('‚ùå Server health check failed');
        }
        
    } catch (error) {
        console.log('‚ùå Server timeout check failed:', error.message);
    }
}

// === TEXT-TO-SPEECH FUNCTIONS ===

let currentAudio = null; // Track currently playing audio
let speechQueue = []; // Queue for multiple TTS requests

async function speakMessage(messageId) {
    console.log('[speakMessage] Called with messageId:', messageId);
    const messageDiv = document.getElementById(messageId);
    if (!messageDiv) {
        console.error('[speakMessage] Message not found:', messageId);
        return;
    }
    const speakerBtn = messageDiv.querySelector('.speaker-btn');
    const text = messageDiv.getAttribute('data-text');
    console.log('[speakMessage] Text to speak:', text);
    if (!text || text.trim() === '') {
        console.warn('[speakMessage] No text to speak for message:', messageId);
        showWarningNotification('Kh√¥ng c√≥ vƒÉn b·∫£n ƒë·ªÉ ƒë·ªçc', 'Tin nh·∫Øn n√†y kh√¥ng c√≥ n·ªôi dung vƒÉn b·∫£n.');
        return;
    }
    // Stop current audio if playing
    if (currentAudio) {
        console.log('[speakMessage] Stopping current audio before playing new.');
        stopCurrentSpeech();
    }
    try {
        // Update button state to loading
        speakerBtn.classList.add('loading');
        speakerBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        speakerBtn.title = 'ƒêang x·ª≠ l√Ω...';
        console.log('[speakMessage] Sending text to TextToSpeech service:', text.substring(0, 100) + '...');
        // Send request to TextToSpeech service
        const response = await fetch('/tts/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                text: text
            })
        });
        console.log('[speakMessage] /tts/ response status:', response.status);
        if (response.ok) {
            const result = await response.json();
            console.log('[speakMessage] /tts/ response result:', result);
            if (result.audio_url) {
                // Play the audio
                await playAudio(result.audio_url, speakerBtn, messageId);
                showSuccessNotification('üîä ƒêang ph√°t √¢m thanh', 'Tin nh·∫Øn ƒëang ƒë∆∞·ª£c ƒë·ªçc b·∫±ng gi·ªçng n√≥i t·ª´ FPT.AI.');
            } else {
                console.error('[speakMessage] No audio_url in result:', result);
                throw new Error('Kh√¥ng th·ªÉ t·∫°o √¢m thanh: kh√¥ng c√≥ audio_url');
            }
        } else {
            const errorData = await response.json().catch(() => null);
            console.error('[speakMessage] /tts/ error response:', errorData);
            throw new Error(errorData.error || errorData.message || `HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        console.error('[speakMessage] ‚ùå Text-to-speech error:', error);
        // Reset button state
        speakerBtn.classList.remove('loading', 'playing');
        speakerBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        speakerBtn.title = 'ƒê·ªçc tin nh·∫Øn';
        showErrorNotification(
            '‚ùå <strong>L·ªói Text-to-Speech:</strong>',
            `Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh gi·ªçng n√≥i: ${error.message}<br><br>
             üí° <strong>C√°c nguy√™n nh√¢n c√≥ th·ªÉ:</strong><br>
             ‚Ä¢ FPT.AI API key ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh<br>
             ‚Ä¢ K·∫øt n·ªëi m·∫°ng kh√¥ng ·ªïn ƒë·ªãnh<br>
             ‚Ä¢ VƒÉn b·∫£n qu√° d√†i ho·∫∑c ch·ª©a k√Ω t·ª± ƒë·∫∑c bi·ªát<br>
             ‚Ä¢ Service FPT.AI t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng`
        );
        // Fallback to browser's built-in speech synthesis
        fallbackToBuiltInTTS(text, speakerBtn);
    }
}

async function playAudio(audioUrl, speakerBtn, messageId) {
    return new Promise((resolve, reject) => {
        // Create audio element
        const audio = new Audio(audioUrl);
        currentAudio = audio;
        
        // Update button state to playing
        speakerBtn.classList.remove('loading');
        speakerBtn.classList.add('playing');
        speakerBtn.innerHTML = '<i class="fas fa-stop"></i>';
        speakerBtn.title = 'D·ª´ng ph√°t';
        
        // Add click listener to stop playback
        const stopHandler = () => {
            stopCurrentSpeech();
        };
        speakerBtn.removeEventListener('click', stopHandler); // Remove any existing listeners
        speakerBtn.addEventListener('click', stopHandler);
        
        // Audio event handlers
        audio.onloadstart = () => {
            console.log('üîä Audio loading started');
        };
        
        audio.oncanplay = () => {
            console.log('üîä Audio can start playing');
        };
        
        audio.onplay = () => {
            console.log('üîä Audio playback started');
        };
        
        audio.onended = () => {
            console.log('üîä Audio playback finished');
            resetSpeakerButton(speakerBtn);
            currentAudio = null;
            resolve();
        };
        
        audio.onerror = (e) => {
            console.error('üîä Audio playback error:', e);
            resetSpeakerButton(speakerBtn);
            currentAudio = null;[speakMessage]
            reject(new Error('Audio playback failed'));
        };
        
        // Start playback
        audio.play().catch(error => {
            console.error('üîä Failed to start audio playback:', error);
            resetSpeakerButton(speakerBtn);
            currentAudio = null;
            reject(error);
        });
    });
}

function stopCurrentSpeech() {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
        
        // Reset all playing speaker buttons
        document.querySelectorAll('.speaker-btn.playing').forEach(btn => {
            resetSpeakerButton(btn);
        });
        
        console.log('üîä Speech stopped');
    }
    
    // Also stop browser's built-in speech synthesis
    if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
    }
}

function resetSpeakerButton(speakerBtn) {
    speakerBtn.classList.remove('loading', 'playing');
    speakerBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
    speakerBtn.title = 'ƒê·ªçc tin nh·∫Øn';
    
    // Remove stop event listener and restore speak functionality
    const messageId = speakerBtn.closest('.message').id;
    speakerBtn.setAttribute('onclick', `speakMessage('${messageId}')`);
}

// Fallback to browser's built-in Text-to-Speech
function fallbackToBuiltInTTS(text, speakerBtn) {
    if ('speechSynthesis' in window) {
        try {
            // Stop any ongoing speech
            window.speechSynthesis.cancel();
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Try to find Vietnamese voice
            const voices = window.speechSynthesis.getVoices();
            const vietnameseVoice = voices.find(voice => 
                voice.lang.startsWith('vi') || 
                voice.name.toLowerCase().includes('vietnamese') ||
                voice.name.toLowerCase().includes('vietnam')
            );
            
            if (vietnameseVoice) {
                utterance.voice = vietnameseVoice;
                utterance.lang = 'vi-VN';
            } else {
                utterance.lang = 'en-US'; // Fallback to English
            }
            
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            // Event handlers
            utterance.onstart = () => {
                speakerBtn.classList.add('playing');
                speakerBtn.innerHTML = '<i class="fas fa-stop"></i>';
                speakerBtn.title = 'D·ª´ng ph√°t (Browser TTS)';
                console.log('üîä Browser TTS started');
            };
            
            utterance.onend = () => {
                resetSpeakerButton(speakerBtn);
                console.log('üîä Browser TTS finished');
            };
            
            utterance.onerror = (event) => {
                resetSpeakerButton(speakerBtn);
                console.error('üîä Browser TTS error:', event);
                showErrorNotification('‚ùå TTS Error', 'Kh√¥ng th·ªÉ s·ª≠ d·ª•ng Text-to-Speech c·ªßa tr√¨nh duy·ªát');
            };
            
            // Start speech
            window.speechSynthesis.speak(utterance);
            showInfoNotification(
                'üîä <strong>S·ª≠ d·ª•ng TTS c·ªßa tr√¨nh duy·ªát</strong>',
                'ƒêang s·ª≠ d·ª•ng Text-to-Speech t√≠ch h·ª£p c·ªßa tr√¨nh duy·ªát thay th·∫ø.'
            );
        } catch (error) {
            console.error('üîä Browser TTS fallback failed:', error);
            resetSpeakerButton(speakerBtn);
            showErrorNotification('‚ùå Kh√¥ng s·ª≠ d·ª•ng ƒë∆∞·ª£c TextToSpeech', 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ho·∫∑c ƒë√£ ch·∫∑n Text-to-Speech.');
        }
    } else {
        resetSpeakerButton(speakerBtn);
        showErrorNotification('‚ùå Kh√¥ng s·ª≠ d·ª•ng ƒë∆∞·ª£c TextToSpeech', 'Tr√¨nh duy·ªát n√†y kh√¥ng h·ªó tr·ª£ ho·∫∑c ƒë√£ ch·∫∑n Text-to-Speech.');
    }
}

// Test TextToSpeech service connection
async function testTextToSpeech() {
    try {
        showInfoNotification('üîä ƒêang ki·ªÉm tra TextToSpeech service...', 'Vui l√≤ng ch·ªù m·ªôt ch√∫t');
        
        // Test with a simple Vietnamese text
        const response = await fetch('/tts/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                text: 'Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi WoxionChat. H·ªá th·ªëng Text-to-Speech ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.'
            })
        });
        
        if (!response.ok) {
            throw new Error('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• TextToSpeech');
        }
        const result = await response.json();
        if (!result || !result.audio_url) {
            throw new Error('D·ªãch v·ª• TextToSpeech kh√¥ng tr·∫£ v·ªÅ audio h·ª£p l·ªá');
        }
        showSuccessNotification('‚úÖ TextToSpeech ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng!', 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i.');
    } catch (error) {
        console.error('‚ùå L·ªói TextToSpeech:', error);
        showErrorNotification('‚ùå Kh√¥ng s·ª≠ d·ª•ng ƒë∆∞·ª£c TextToSpeech', error.message || 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ho·∫∑c d·ªãch v·ª• kh√¥ng kh·∫£ d·ª•ng.');
    }
}

// === STUDIO TAB SYSTEM ===

// Switch between studio tabs
function switchStudioTab(tabName) {
    // Remove active class from all tabs and content
    document.querySelectorAll('.studio-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.studio-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Add active class to selected tab and content
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    document.getElementById(tabName + 'Tab').classList.add('active');
    
    // Update saved messages display when switching to saved tab
    if (tabName === 'saved') {
        updateStudioSavedMessages();
    }
}

// === SAVED MESSAGES FUNCTIONS ===

// Toggle pin status for a message
function toggleMessagePin(messageId) {
    const messageDiv = document.getElementById(messageId);
    const pinBtn = messageDiv.querySelector('.pin-btn');
    
    if (!messageDiv || !pinBtn) {
        console.error('Message or pin button not found:', messageId);
        return;
    }
    
    const isPinned = pinBtn.classList.contains('pinned');
    
    if (isPinned) {
        // Unpin the message
        unpinMessage(messageId);
    } else {
        // Pin the message
        pinMessage(messageId);
    }
}

// Pin a message
function pinMessage(messageId) {
    const messageDiv = document.getElementById(messageId);
    const pinBtn = messageDiv.querySelector('.pin-btn');
    const content = messageDiv.querySelector('.message-content').innerHTML;
    const cleanText = messageDiv.getAttribute('data-text');
    const timeString = messageDiv.querySelector('.message-time').textContent;
    
    // Create saved message object
    const savedMessage = {
        id: messageId,
        content: content,
        cleanText: cleanText,
        timestamp: new Date().toISOString(),
        displayTime: timeString
    };
    
    // Get existing saved messages
    const savedMessages = getSavedMessages();
    
    // Add new message if not already saved
    if (!savedMessages.find(msg => msg.id === messageId)) {
        savedMessages.push(savedMessage);
        localStorage.setItem('studio_saved_messages', JSON.stringify(savedMessages));
        
        // Update button state
        pinBtn.classList.add('pinned');
        pinBtn.title = 'B·ªè ghim tin nh·∫Øn';
        
        // Update studio display
        updateStudioSavedMessages();
        updateStudioSavedCounter();
        
        // Show notification
        showSuccessNotification('üìå ƒê√£ ghim tin nh·∫Øn!', 'Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o Studio.');
        
        console.log('üìå Message pinned:', messageId);
    }
}

// Unpin a message
function unpinMessage(messageId) {
    const messageDiv = document.getElementById(messageId);
    const pinBtn = messageDiv.querySelector('.pin-btn');
    
    // Get existing saved messages
    const savedMessages = getSavedMessages();
    
    // Remove message from saved list
    const updatedMessages = savedMessages.filter(msg => msg.id !== messageId);
    localStorage.setItem('studio_saved_messages', JSON.stringify(updatedMessages));
    
    // Update button state
    pinBtn.classList.remove('pinned');
    pinBtn.title = 'Ghim tin nh·∫Øn';
    
    // Update studio display
    updateStudioSavedMessages();
    updateStudioSavedCounter();
    
    // Show notification
    showInfoNotification('üìå ƒê√£ b·ªè ghim tin nh·∫Øn!', 'Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi Studio.');
    
    console.log('üìå Message unpinned:', messageId);
}

// Get saved messages from localStorage
function getSavedMessages() {
    try {
        const savedMessages = localStorage.getItem('studio_saved_messages');
        return savedMessages ? JSON.parse(savedMessages) : [];
    } catch (error) {
        console.error('Error loading saved messages:', error);
        return [];
    }
}

// Update studio saved messages display
function updateStudioSavedMessages() {
    const studioSavedMessages = document.getElementById('studioSavedMessages');
    const savedMessages = getSavedMessages();
    
    if (savedMessages.length === 0) {
        studioSavedMessages.innerHTML = `
            <div class="studio-empty-state">
                <i class="fas fa-thumbtack"></i>
                <p>Ch∆∞a c√≥ tin nh·∫Øn n√†o ƒë∆∞·ª£c ghim</p>
                <small>Nh·∫•p v√†o bi·ªÉu t∆∞·ª£ng ghim üìå ·ªü tin nh·∫Øn bot ƒë·ªÉ l∆∞u l·∫°i</small>
            </div>
        `;
        return;
    }
    
    // Sort messages by timestamp (newest first)
    savedMessages.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    studioSavedMessages.innerHTML = savedMessages.map(msg => `
        <div class="studio-saved-item">
            <div class="studio-saved-time">
                <i class="fas fa-clock"></i> ${msg.displayTime} - ${formatDate(msg.timestamp)}
            </div>
            <div class="studio-saved-content">${msg.content}</div>
            <div class="studio-saved-actions">
                <button class="btn-copy" onclick="copyStudioSavedMessage('${msg.id}')" title="Sao ch√©p">
                    <i class="fas fa-copy"></i>
                </button>
                <button class="btn-delete" onclick="removeStudioSavedMessage('${msg.id}')" title="X√≥a">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// Update saved messages counter
function updateStudioSavedCounter() {
    const savedMessages = getSavedMessages();
    const counter = document.getElementById('studioSavedCounter');
    const clearBtn = document.querySelector('.studio-clear-btn');
    
    if (savedMessages.length > 0) {
        counter.textContent = savedMessages.length;
        counter.style.display = 'inline-block';
        clearBtn.disabled = false;
    } else {
        counter.style.display = 'none';
        clearBtn.disabled = true;
    }
}

// Copy saved message to clipboard
function copyStudioSavedMessage(messageId) {
    const savedMessages = getSavedMessages();
    const message = savedMessages.find(msg => msg.id === messageId);
    
    if (message) {
        const textToCopy = message.cleanText || message.content.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
        
        navigator.clipboard.writeText(textToCopy).then(() => {
            showSuccessNotification('üìã ƒê√£ sao ch√©p tin nh·∫Øn!', 'N·ªôi dung tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c sao ch√©p v√†o clipboard.');
        }).catch(error => {
            console.error('Failed to copy text:', error);
            showErrorNotification('‚ùå Kh√¥ng th·ªÉ sao ch√©p', 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ho·∫∑c ƒë√£ ch·∫∑n ch·ª©c nƒÉng sao ch√©p.');
        });
    }
}

// Remove saved message
function removeStudioSavedMessage(messageId) {
    const savedMessages = getSavedMessages();
    const updatedMessages = savedMessages.filter(msg => msg.id !== messageId);
    localStorage.setItem('studio_saved_messages', JSON.stringify(updatedMessages));
    
    // Update button state in chat if message still exists
    const messageDiv = document.getElementById(messageId);
    if (messageDiv) {
        const pinBtn = messageDiv.querySelector('.pin-btn');
        if (pinBtn) {
            pinBtn.classList.remove('pinned');
            pinBtn.title = 'Ghim tin nh·∫Øn';
        }
    }
    
    // Update studio display
    updateStudioSavedMessages();
    updateStudioSavedCounter();
    
    showInfoNotification('üóëÔ∏è ƒê√£ x√≥a tin nh·∫Øn kh·ªèi Studio!');
}

// Clear all saved messages
function clearAllSavedMessages() {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ tin nh·∫Øn ƒë√£ ghim?')) {
        localStorage.removeItem('studio_saved_messages');
        
        // Reset all pin buttons in chat
        document.querySelectorAll('.pin-btn.pinned').forEach(btn => {
            btn.classList.remove('pinned');
            btn.title = 'Ghim tin nh·∫Øn';
        });
        
        // Update studio display
        updateStudioSavedMessages();
        updateStudioSavedCounter();
        
        showInfoNotification('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ tin nh·∫Øn ƒë√£ ghim!');
    }
}

// Initialize saved messages on page load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize saved messages counter
    updateStudioSavedCounter();
    
    // Update pin button states for existing messages
    const savedMessages = getSavedMessages();
    savedMessages.forEach(msg => {
        const messageDiv = document.getElementById(msg.id);
        if (messageDiv) {
            const pinBtn = messageDiv.querySelector('.pin-btn');
            if (pinBtn) {
                pinBtn.classList.add('pinned');
                pinBtn.title = 'B·ªè ghim tin nh·∫Øn';
            }
        }
    });
    
    console.log('üìå Studio saved messages initialized:', savedMessages.length, 'messages');
});

// Keyboard shortcuts for studio
document.addEventListener('keydown', function(event) {
    // Ctrl+Shift+S to switch to saved messages tab
    if (event.ctrlKey && event.shiftKey && event.key === 'S') {
        event.preventDefault();
        switchStudioTab('saved');
    }
    
    // Ctrl+Shift+N to switch to notes tab
    if (event.ctrlKey && event.shiftKey && event.key === 'N') {
        event.preventDefault();
        switchStudioTab('notes');
    }
    
    // Ctrl+Shift+C to clear all saved messages
    if (event.ctrlKey && event.shiftKey && event.key === 'C') {
        event.preventDefault();
        clearAllSavedMessages();
    }
});
document.addEventListener('DOMContentLoaded', fetchNotes);

// New function to add bot messages with typewriter effect
function addBotMessageWithTypewriter(content) {
    const chatBody = document.getElementById('chatBody');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message bot';
    
    const now = new Date();
    const timeString = now.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
    
    // Generate unique ID for this message
    const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    messageDiv.id = messageId;
    
    // Process content
    let processedContent = content;
    let cleanText = content;
    
    // Check if content looks like Markdown
    if (isMarkdownContent(content)) {
        try {
            // Configure marked.js for safe rendering
            marked.setOptions({
                breaks: true,
                gfm: true,
                sanitize: false,
                smartLists: true,
                smartypants: true
            });
            
            // Convert Markdown to HTML
            processedContent = marked.parse(content);
            console.log('üìù Converted Markdown to HTML for bot message');
        } catch (error) {
            console.error('‚ùå Error parsing Markdown:', error);
            // Fallback to original content if Markdown parsing fails
            processedContent = content;
        }
    }
    
    // Extract clean text for TTS (remove HTML tags)
    cleanText = processedContent.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
    
    // Create buttons for bot messages
    const buttonsHtml = `
        <button class="pin-btn" onclick="toggleMessagePin('${messageId}')" title="Ghim tin nh·∫Øn">
            <i class="fas fa-thumbtack"></i>
        </button>
        <button class="speaker-btn" onclick="speakMessage('${messageId}')" title="ƒê·ªçc tin nh·∫Øn">
            <i class="fas fa-volume-up"></i>
        </button>
    `;
    
    // Create initial message structure with empty content
    messageDiv.innerHTML = `
        <div class="message-content" id="content-${messageId}"></div>
        <div class="message-footer">
            <div class="message-time" style="align-items: center;">${timeString}</div>
            ${buttonsHtml}
        </div>
    `;
    
    // Store clean text as data attribute for TTS
    messageDiv.setAttribute('data-text', cleanText);
    
    // Add to chat body
    chatBody.appendChild(messageDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
    
    // Start typewriter effect
    typewriterEffect(processedContent, `content-${messageId}`);
}

// Typewriter effect function
function typewriterEffect(text, elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    // Add typing class to message container
    const messageDiv = element.closest('.message');
    if (messageDiv) {
        messageDiv.classList.add('typing');
    }
    
    let currentIndex = 0;
    let currentText = '';
    const speed = 20; // Speed in milliseconds (lower = faster)
    const chatBody = document.getElementById('chatBody');
    
    function typeNext() {
        if (currentIndex < text.length) {
            currentText += text[currentIndex];
            element.innerHTML = currentText + '<span class="typewriter-cursor">|</span>';
            
            // Auto-scroll to bottom while typing
            chatBody.scrollTop = chatBody.scrollHeight;
            
            currentIndex++;
            setTimeout(typeNext, speed);
        } else {
            // Animation completed - remove cursor and typing class
            element.innerHTML = text;
            if (messageDiv) {
                messageDiv.classList.remove('typing');
            }
            chatBody.scrollTop = chatBody.scrollHeight;
        }
    }
    
    typeNext();
}

// Enhanced function to add messages with typewriter effect for bot messages
function addMessageWithTypewriter(content, type) {
    if (type === 'bot') {
        addBotMessageWithTypewriter(content);
    } else {
        addMessage(content, type);
    }
}

// New function to search data
function searchData() {
    // Add your search logic here
    console.log('Searching data...');
}

// New function to test typewriter effect
function testTypewriter() {
    // Add your typewriter test logic here
    console.log('Testing typewriter effect...');
}

</script>
 
 {% endblock %}